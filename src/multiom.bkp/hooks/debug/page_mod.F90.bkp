MODULE PAGE_MOD
  IMPLICIT NONE
  INTEGER, PARAMETER :: LINE_LENGTH = 128
  INTEGER, PARAMETER :: PAGE_LENGTH = 512
  INTEGER, PARAMETER :: ERR_STRING_TOO_LONG = -1

  TYPE :: PAGE_T
    CHARACTER(LEN=LINE_LENGTH), DIMENSION(PAGE_LENGTH), ALLOCATABLE :: LINES
    INTEGER :: CURRENT_LINE, CURRENT_COL
  CONTAINS
    PROCEDURE :: INIT       => PAGE_INIT
    PROCEDURE :: WRITE      => PAGE_WRITE
    PROCEDURE :: WRITE_TRIM => PAGE_WRITE_TRIM
    PROCEDURE :: NEW_LINE   => PAGE_NEW_LINE
    PROCEDURE :: PRINT      => PAGE_PRINT
  END TYPE

CONTAINS

  SUBROUTINE PAGE_INIT(SELF)
    CLASS(PAGE_T), INTENT(INOUT) :: SELF
    ALLOCATE(SELF%LINES(PAGE_LENGTH))
    SELF%CURRENT_LINE = 1   ! START AT THE FIRST LINE
    SELF%CURRENT_COL = 0    ! START AT THE FIRST COLUMN
  END SUBROUTINE PAGE_INIT

  SUBROUTINE PAGE_NEW_LINE(SELF, IOS)
    CLASS(PAGE_T), INTENT(INOUT) :: SELF
    INTEGER, INTENT(OUT) :: IOS
    ! MOVE TO THE NEXT LINE IF AVAILABLE
    IF (SELF%CURRENT_LINE < PAGE_LENGTH) THEN
      SELF%CURRENT_LINE = SELF%CURRENT_LINE + 1
      SELF%CURRENT_COL = 0  ! RESET COLUMN TO START OF THE NEW LINE
      IOS = 0
    ELSE
      IOS = 1  ! NO MORE LINES AVAILABLE, PAGE IS FULL
    END IF
  END SUBROUTINE PAGE_NEW_LINE

  RECURSIVE SUBROUTINE PAGE_WRITE(SELF, INPUT_STRING, ADVANCE, TRIM_STRING, IOS)
  IMPLICIT NONE

    ! Dummy arguments
    CLASS(PAGE_T),     INTENT(INOUT) :: SELF
    CHARACTER(LEN=*),  INTENT(IN)    :: INPUT_STRING
    LOGICAL, OPTIONAL, INTENT(IN)    :: ADVANCE
    INTEGER, OPTIONAL, INTENT(OUT)   :: IOS
    LOGICAL, OPTIONAL, INTENT(IN)    :: TRIM_STRING

    ! Local variables
    INTEGER :: STR_LEN
    LOGICAL :: LOC_ADVANCE
    INTEGER :: LOC_IOS
    LOGICAL :: LOC_TRIM_STRING

    IF ( PRESENT(ADVANCE) ) THEN
      LOC_ADVANCE = ADVANCE
    ELSE
      LOC_ADVANCE = .TRUE.
    ENDIF

    IF ( PRESENT(TRIM_STRING) ) THEN
      LOC_TRIM_STRING = TRIM_STRING
    ELSE
      LOC_TRIM_STRING = .FALSE.
    ENDIF


    STR_LEN = LEN(INPUT_STRING)

    ! CHECK IF THE INPUT STRING IS LONGER THAN THE ALLOWED LINE LENGTH
    IF ( (.NOT.LOC_TRIM_STRING) .AND. (STR_LEN.GT.LINE_LENGTH) ) THEN
      IF ( PRESENT(IOS) ) THEN
        IOS = ERR_STRING_TOO_LONG
      ENDIF
      RETURN
    END IF

    ! CHECK IF THE STRING FITS IN THE CURRENT LINE
    IF (SELF%CURRENT_COL + STR_LEN <= LINE_LENGTH) THEN
      ! IT FITS, SO APPEND TO THE CURRENT LINE
      SELF%LINES(SELF%CURRENT_LINE)(SELF%CURRENT_COL+1:SELF%CURRENT_COL+STR_LEN) = INPUT_STRING

      IF ( LOC_ADVANCE ) THEN
        SELF%CURRENT_COL = SELF%CURRENT_COL + STR_LEN
      ENDIF
      IF ( PRESENT(IOS) ) THEN
        IOS = 0
      ENDIF

    ELSE

      ! MOVE TO THE NEXT LINE
      CALL SELF%NEW_LINE(IOS)

      ! IF THERE'S NO SPACE LEFT, RETURN ERROR
      IF (IOS /= 0) RETURN

      ! WRITE THE STRING TO THE NEW LINE (STARTING FROM THE BEGINNING OF THE LINE)
      CALL SELF%WRITE( INPUT_STRING, LOC_ADVANCE, LOC_TRIM_STRING, IOS )

    END IF
  END SUBROUTINE PAGE_WRITE

  RECURSIVE SUBROUTINE PAGE_WRITE_TRIM(SELF, INPUT_STRING, IOS )
    CLASS(PAGE_T), INTENT(INOUT) :: SELF
    CHARACTER(LEN=*), INTENT(INOUT) :: INPUT_STRING
    INTEGER, INTENT(OUT) :: IOS
    LOGICAL, OPTIONAL, INTENT(IN) :: ADVANCE
    INTEGER :: STR_LEN, REMAINING_SPACE

    STR_LEN = LEN_TRIM(INPUT_STRING)

    ! CALCULATE REMAINING SPACE IN THE CURRENT LINE
    REMAINING_SPACE = LINE_LENGTH - SELF%CURRENT_COL

    ! IF THE STRING FITS IN THE CURRENT LINE, APPEND IT
    IF (STR_LEN <= REMAINING_SPACE) THEN
      SELF%LINES(SELF%CURRENT_LINE)(SELF%CURRENT_COL+1:SELF%CURRENT_COL+STR_LEN) = INPUT_STRING
      SELF%CURRENT_COL = SELF%CURRENT_COL + STR_LEN
      IOS = 0  ! SUCCESS
    ELSE
      ! FILL THE REST OF THE CURRENT LINE WITH PART OF THE STRING
      SELF%LINES(SELF%CURRENT_LINE)(SELF%CURRENT_COL+1:LINE_LENGTH) = INPUT_STRING(1:REMAINING_SPACE)
      CALL SELF%NEW_LINE(IOS)

      ! IF THERE IS NO SPACE LEFT, RETURN ERROR
      IF (IOS /= 0) RETURN

      ! WRITE THE REMAINING PART OF THE STRING TO THE NEW LINE
      INPUT_STRING = INPUT_STRING(REMAINING_SPACE+1:)
      CALL SELF%WRITE_TRIM(INPUT_STRING, IOS)
    END IF
  END SUBROUTINE PAGE_WRITE_TRIM

END MODULE PAGE_MOD