! Include preprocessor utils
#include "output_manager_preprocessor_utils.h"
#include "output_manager_preprocessor_trace_utils.h"
#include "output_manager_preprocessor_logging_utils.h"
#include "output_manager_preprocessor_errhdl_utils.h"


#define PP_FILE_NAME 'plan_mod.F90'
#define PP_SECTION_TYPE 'MODULE'
#define PP_SECTION_NAME 'PLAN_MOD'
MODULE PLAN_MOD

IMPLICIT NONE

PRIVATE


TYPE :: ENCODING_INFO_T

  !> Default visibility of the class
  PRIVATE

  !> Set of plans used to encode the data
  TYPE(SPECIALIZED_PLAN_T), DIMENSION(:), POINTER :: PLANS_ => NULL()

CONTAINS

  !> Initialize the encoding info
  PROCEDURE, PUBLIC, PASS, NON_OVERRIDABLE :: INIT   => ENCODING_INFO_INIT

  !> Encode the message
  PROCEDURE, PUBLIC, PASS, NON_OVERRIDABLE :: ENCODE => ENCODING_INFO_ENCODE

  !> Free all the memory allocated by the encoding info
  PROCEDURE, PUBLIC, PASS, NON_OVERRIDABLE :: FREE   => ENCODING_INFO_FREE

END TYPE




TYPE :: PLAN_T

  !> Default visibility of the class
  PRIVATE

  !> Set of filters used to select the data to be encoded
  CLASS(FILTER_BASE_T), POINTER :: FILTER_ => NULL()

  !> Set of mappings used to remap the data before encoding
  CLASS(MAPPINGS_BASE_T), POINTER :: MAPPINGS_ => NULL()

  !> Set of actions used to encode a GRIB message
  CLASS(PRESET_ENCODER_BASE_T), POINTER :: PRESET_ENCODER_ => NULL()

  !> Set of actions used to encode a GRIB message
  CLASS(RUNTIME_ENCODER_BASE_T), POINTER :: RUNTIME_ENCODERS_ => NULL()

  !> Action used to set the values in the GRIB message
  CLASS(VALUES_ENCODER_T), DIMENSION(:), POINTER :: VALUES_RUNTIME_ENCODERS_ => NULL()

  !> Set of sinks used to store the encoded data
  CLASS(SINK_BASE_T), POINTER, DIMENSION(:) :: SINKS_ => NULL()

CONTAINS

  !> Initialize the plan (read from yaml)
  PROCEDURE, PUBLIC, PASS :: INIT => PLAN_INIT

  !> If the message matches the message, search a valid mapping and
  !> returns the specialized plan already preset
  PROCEDURE, PUBLIC, PASS :: MATCH => PLAN_MATCH

  !> Free all the memory allocated by the plan
  PROCEDURE, PUBLIC, PASS :: FREE  => PLAN_FREE

END TYPE


CONTAINS

SUBROUTINE PLAN_INIT( THIS, PARAMS, CFG, VERBOSE )
IMPLICIT NONE

CLASS(PLAN_T),              INTENT(INOUT) :: THIS
TYPE(PARAMS_T),             INTENT(IN)    :: PARAMS
TYPE(YAML_CONFIGURATION_T), INTENT(IN)    :: CFG
LOGICAL,                    INTENT(IN)    :: VERBOSE

! Read the filter
RET = YAML_CONFIGURATION_HAS_KEY( CFG, "filter", HAS_FILTER, VERBOSE )
PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_FILTER, 1 )
RET = YAML_GET_SUBCONFIGURATION( CFG, "filter", FILTER_RULES, VERBOSE )
RET = READ_RULE_FILTER( FILTER_RULES, THIS%FILTER_, VERBOSE )
RET = YAML_DELETE_CONFIGURATION( FILTER_RULES, VERBOSE )

! Read the mappings
RET = YAML_CONFIGURATION_HAS_KEY( CFG, "mapping", HAS_MAPPING, VERBOSE )
IF ( HAS_MAPPING ) THEN
  RET = YAML_GET_SUBCONFIGURATION( CFG, "mapping", MAPPING_RULES, VERBOSE )
  RET = READ_MAPPINGS(  MAPPING_RULES, THIS%MAPPINGS_,VERBOSE )
  RET = YAML_DELETE_CONFIGURATION( MAPPING_RULES, VERBOSE )
ENDIF

! Read the encoder
RET = YAML_CONFIGURATION_HAS_KEY( CFG, "metadata-encoder", HAS_METADATA_ENCODER, VERBOSE )
PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_METADATA_ENCODER, 2 )
RET = YAML_GET_SUBCONFIGURATION( CFG, "metadata-encoder", METADATA_ENCODER_RULES, VERBOSE )
RET = READ_METADATA_ENCODER( METADATA_ENCODER_RULES, THIS%PRESET_ENCODER_, THIS%RUNTIME_ENCODERS_, VERBOSE )
RET = YAML_DELETE_CONFIGURATION( METADATA_ENCODER_RULES, VERBOSE )

! Read value encoder
RET = YAML_CONFIGURATION_HAS_KEY( CFG, "values-encoder", HAS_VALUES_ENCODER, VERBOSE )
IF ( HAS_VALUES_ENCODER ) THEN
  RET = YAML_GET_SUBCONFIGURATION( CFG, "values-encoder", VALUES_ENCODER_RULES, VERBOSE )
  RET = READ_VALUES_ENCODER( VALUES_ENCODER_RULES, THIS%VALUES_RUNTIME_ENCODER_, VERBOSE )
  RET = YAML_DELETE_CONFIGURATION( VALUES_ENCODER_RULES, VERBOSE )
ENDIF

! Read the sinks
RET = YAML_CONFIGURATION_HAS_KEY( CFG, "sinks", HAS_SINKS, VERBOSE )
PP_DEBUG_CRITICAL_COND_THROW( .NOT.HAS_SINKS, 3 )
RET = YAML_GET_SUBCONFIGURATIONS( CFG, "sinks", SINKS_RULES, VERBOSE )
RET = YAML_GET_CONFIGURATIONS_SIZE( SINKS_RULES, SINKS_SIZE, VERBOSE )
ALLOCATE( THIS%SINKS_(SINKS_SIZE) )
DO I = 1, SINKS_SIZE
  RET = YAML_GET_CONFIGURATION_BY_IDX( SINKS_RULES, I, SINK_RULE, VERBOSE )
  RET = READ_SINK( SINK_RULE, THIS%SINKS_(I), VERBOSE )
  RET = YAML_DELETE_CONFIGURATION( SINK_RULE, VERBOSE )
ENDDO
RET = YAML_DELETE_CONFIGURATIONS( SINKS_RULES, VERBOSE )

RETURN

END SUBROUTINE PLAN_INIT

SUBROUTINE PLAN_MATCH( THIS, PARAMS, MSG, MATCH, SPECIALIZED_PLAN, VERBOSE )
IMPLICIT NONE

! Dummy arguments
CLASS(PLAN_T),                     INTENT(INOUT) :: THIS
TYPE(PARAMS_T),                    INTENT(IN)    :: PARAMS
TYPE(MESSAGE_T),                   INTENT(IN)    :: MSG
LOGICAL,                           INTENT(OUT)   :: MATCH
TYPE(SPECIALIZED_PLAN_T), POINTER, INTENT(OUT)   :: SPECIALIZED_PLAN
LOGICAL,                           INTENT(IN)    :: VERBOSE

!> Check if the current message match the filter
CALL THIS%FILTER_%MATCH( PARAMS, MSG, MATCH, VERBOSE )

!> Allocate the specialized plan
ALLOCATE(SPECIALIZED_PLAN)

!> Initialize the specialized plan
ALLOCATE( TIME_HIST )
TIME_HIST%INIT( THIS%CAPACITY_ ) ! Todo: read capacity from yaml configutation

! Allocate the metadata
IF ( .NOT. PRESENT(MULTIO_HANDLE) ) THEN
  ALLOCATE( METADATA::GRIB_METADATA_T )
ELSE
  ALLOCATE( METADATA::MULTIO_METADATA_T )
ENDIF

! Initialize the sections
CALL THIS%FILTER_%MATCH( PARAMS, MSG, MATCH, PLAN, VERBOSE )
CALL PLAN%MAPPINGS_%MATCH( PARAMS, MSG, MATCH, MAPPING, VERBOSE )

! Preset the sample
CALL PLAN%ENCODER%PRESET( PARAMS, METADATA, VERBOSE)

! Get the runtime ops
CALL PLAN%ENCODER%GET_RUNTIME_OPS( PARAMS, MSG, RUNTIME_OPS, VERBOSE )

!> Initialize the specialized plan
CALL SPECIALIZED_PLAN%INIT( TIME_HIST, METADATA, MAPPING, THIS%VALUES_RUNTIME_ENCODER_, THIS%SINKS_, VERBOSE )

!> Exit with success
RETURN

END SUBROUTINE PLAN_MATCH

SUBROUTINE PLAN_FREE( THIS, VERBOSE )
IMPLICIT NONE

! Dummy arguments
CLASS(PLAN_T),            INTENT(INOUT) :: THIS
LOGICAL,                  INTENT(IN)    :: VERBOSE

IF ( ASSOCIATED(THIS%FILTER_) ) THEN
  CALL THIS%FILTER_%FREE()
  DEALLOCATE(THIS%FILTER_)
ENDIF

IF ( ASSOCIATED(THIS%MAPPINGS_) ) THEN
  CALL THIS%MAPPINGS_%FREE()
  DEALLOCATE(THIS%MAPPINGS_)
ENDIF

IF ( ASSOCIATED(THIS%PRESET_ENCODER_) ) THEN
  CALL THIS%PRESET_ENCOD_%FREE()
  DEALLOCATE(THIS%PRESET_ENCODER_)
ENDIF

IF ( ASSOCIATED(THIS%RUNTIME_ENCODER_) ) THEN
  CALL THIS%RUNTIME_ENCODER_%FREE()
  DEALLOCATE(THIS%RUNTIME_ENCODER_)
ENDIF

IF ( ASSOCIATED(THIS%VALUES_RUNTIME_ENCODER_) ) THEN
  CALL THIS%VALUES_RUNTIME_ENCODER_%FREE()
  DEALLOCATE(THIS%VALUES_RUNTIME_ENCODER_)
ENDIF

IF ( ASSOCIATED(THIS%SINKS_) ) THEN
  DO I = 1, SIZE(THIS%SINKS_)
    CALL THIS%SINKS_(I)%FREE()
  ENDDO
  DEALLOCATE(THIS%SINKS_)
ENDIF

RETURN


END SUBROUTINE PLAN_FREE

END MODULE PLAN_MOD
#undef PP_SECTION_NAME
#undef PP_SECTION_TYPE
#undef PP_FILE_NAME