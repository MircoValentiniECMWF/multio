!>
!> @file yaml_core_utils_mod.f90
!>
!> @brief Provides utility routines for handling YAML configurations.
!>
!> This module contains various routines for managing YAML configurations, including reading,
!> creating, and manipulating configurations from files or memory. It supports functionalities such
!> as retrieving, deleting, and checking configurations, as well as handling errors and debugging.
!>
!> @section Public DataTypes
!> The module defines the following types:
!>  - @ref YAML_CONFIGURATION_T
!>  - @ref YAML_CONFIGURATIONS_T
!>
!> @section Public Interfaces
!> The module includes the following interfaces:
!>  - @ref FUN_C2I_IF
!>
!> @section Public Routines
!> The module includes the following procedures:
!>   - @ref YAML_NEW_CONFIGURATION_FROM_FILE
!>   - @ref YAML_DELETE_CONFIGURATION
!>   - @ref YAML_DELETE_CONFIGURATIONS
!>   - @ref YAML_GET_SUBCONFIGURATION
!>   - @ref YAML_GET_SUBCONFIGURATIONS
!>   - @ref YAML_GET_CONFIGURATIONS_SIZE
!>   - @ref YAML_GET_CONFIGURATION_BY_ID
!>   - @ref YAML_CONFIGURATION_HAS_KEY
!>   - @ref YAML_READ_STRING_ARRAY
!>   - @ref YAML_READ_INTEGER_ARRAY_WITH_FILTER
!>   - @ref YAML_READ_INTEGER_ARRAY_WITH_RANGES
!>   - @ref YAML_READ_INTEGER_ARRAY
!>   - @ref YAML_READ_FLOAT
!>   - @ref YAML_READ_INTEGER
!>   - @ref YAML_READ_STRING
!>   - @ref YAML_READ_LOGICAL
!>
!> @section Private Routines
!> The module includes the following procedures:
!>   - @ref READ_INTEGER_PATTERNS
!>   - @ref READ_INTEGER
!>
!> @author Mirco Valentini
!> @date   August, 2024
!>


! Include preprocessor utils
#include "output_manager_preprocessor_utils.h"
#include "output_manager_preprocessor_trace_utils.h"
#include "output_manager_preprocessor_logging_utils.h"
#include "output_manager_preprocessor_errhdl_utils.h"


#define PP_FILE_NAME 'yaml_core_utils_mod.F90'
#define PP_SECTION_TYPE 'MODULE'
#define PP_SECTION_NAME 'MODULE YAML_CORE_UTILS_MOD'
MODULE YAML_CORE_UTILS_MOD

  !> Simbols imported from external libraries
  USE :: FCKIT_CONFIGURATION_MODULE, ONLY: FCKIT_CONFIGURATION

IMPLICIT NONE

!> Default symbols visibility
PRIVATE

!>
!> @class main object representing a YAML configuration
TYPE :: YAML_CONFIGURATION_T

  !> @brief Flag used to check if the configuration is allocated of just a reference
  LOGICAL :: IS_ALLOCATED_ = .FALSE.

  !> @brief Pointer to the actual configuration object
  TYPE(FCKIT_CONFIGURATION), POINTER :: CFG_ => NULL()

ENDTYPE


!>
!> @class object representing an array of YAML configurations
TYPE :: YAML_CONFIGURATIONS_T

  !> @brief Pointer to the array of configurations
  TYPE(FCKIT_CONFIGURATION), DIMENSION(:), ALLOCATABLE :: CFGS_
ENDTYPE


!>
!> Interface for the function converting a characters to an integer
!> To be used for example when reading anumerators by name
INTERFACE
  PP_THREAD_SAFE FUNCTION FUN_C2I_IF( CHAR, I, HOOKS ) RESULT( RET )

    ! Symbols imported from other modules within the project.
    USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
    USE :: HOOKS_MOD,         ONLY: HOOKS_T

    ! Symbols imported by the preprocessor for debugging purposes
    PP_DEBUG_USE_VARS

    ! Symbols imported by the preprocessor for logging purposes
    PP_LOG_USE_VARS

    ! Symbols imported by the preprocessor for tracing purposes
    PP_TRACE_USE_VARS

  IMPLICIT NONE

    ! Dummy arguments
    CHARACTER(LEN=*),     INTENT(IN)    :: CHAR
    INTEGER(KIND=JPIB_K), INTENT(OUT)   :: I
    TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS
    INTEGER(KIND=JPIB_K) :: RET
  END FUNCTION FUN_C2I_IF
END INTERFACE


!>
!> Public symbols visibility (datatypes)
PUBLIC :: YAML_CONFIGURATION_T
PUBLIC :: YAML_CONFIGURATIONS_T

!> Public symbols visibility (interfaces)
PUBLIC :: FUN_C2I_IF

!> Public symbols visibility (subroutines)
PUBLIC :: YAML_NEW_CONFIGURATION_FROM_FILE
PUBLIC :: YAML_DELETE_CONFIGURATION
PUBLIC :: YAML_DELETE_CONFIGURATIONS
PUBLIC :: YAML_GET_SUBCONFIGURATION
PUBLIC :: YAML_GET_SUBCONFIGURATIONS
PUBLIC :: YAML_GET_CONFIGURATIONS_SIZE
PUBLIC :: YAML_GET_CONFIGURATION_BY_ID
PUBLIC :: YAML_CONFIGURATION_HAS_KEY
PUBLIC :: YAML_READ_STRING_ARRAY
PUBLIC :: YAML_READ_INTEGER_ARRAY_WITH_FILTER
PUBLIC :: YAML_READ_INTEGER_ARRAY_WITH_RANGES
PUBLIC :: YAML_READ_INTEGER_ARRAY
PUBLIC :: YAML_READ_FLOAT
PUBLIC :: YAML_READ_INTEGER
PUBLIC :: YAML_READ_STRING
PUBLIC :: YAML_READ_LOGICAL

PUBLIC :: STRING_IS_INTEGER
PUBLIC :: STRING_IS_INTEGER_RANGE
PUBLIC :: STRING_IS_INTEGER_RANGE_BY
PUBLIC :: STRING_TO_INTEGER
PUBLIC :: STRING_TO_INTEGER_RANGE
PUBLIC :: STRING_TO_INTEGER_RANGE_BY

CONTAINS


!>
!> @brief Creates a new YAML configuration from a file.
!>
!> This function reads a YAML file specified by `YAML_FILE_NAME` and creates a new YAML configuration,
!> which is then returned in the `VALUE` argument.
!>
!> @section interface
!> @param [in] YAML_FILE_NAME The name of the YAML file from which the configuration will be read.
!> @param [out] VALUE The new YAML configuration object created from the file.
!> @param [inout] HOOKS Utilities to be used for logging, debugging, tracing and option handling
!>
!> @return Integer error code (`RET`) indicating the result of the operation.
!>         Possible values:
!>           - `0`: Success
!>           - `1`: Failure
!>
!> @section Dependencies of this function:
!>
!> @subsection module dependencies
!>   - @dependency [TYPE] YAML_CONFIGURATION_T
!>
!> @subsection local dependencies
!>   - @dependency [PARAMETER] DATAKINDS_DEF_MOD::JPIB_K
!>
!> @subsection external dependencies
!>   - @dependency [PROCEDURE] FCKIT_PATHNAME_MODULE::FCKIT_PATHNAME
!>   - @dependency [PROCEDURE] FCKIT_CONFIGURATION_MODULE::FCKIT_YAMLCONFIGURATION
!>
!> @subsection special dependencies
!>   - @dependency [*] PP_DEBUG_USE_VARS::*
!>   - @dependency [*] PP_LOG_USE_VARS::*
!>   - @dependency [*] PP_TRACE_USE_VARS::*
!>
#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'YAML_NEW_CONFIGURATION_FROM_FILE'
PP_THREAD_SAFE FUNCTION YAML_NEW_CONFIGURATION_FROM_FILE( YAML_FILE_NAME, VALUE, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported from other libraries
  USE  :: FCKIT_PATHNAME_MODULE,      ONLY: FCKIT_PATHNAME
  USE  :: FCKIT_CONFIGURATION_MODULE, ONLY: FCKIT_YAMLCONFIGURATION

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  CHARACTER(LEN=*),           INTENT(IN)    :: YAML_FILE_NAME
  TYPE(YAML_CONFIGURATION_T), INTENT(OUT)   :: VALUE
  TYPE(HOOKS_T),              INTENT(INOUT) :: HOOKS

  ! Function return value
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  LOGICAL :: FILE_EXISTS
  INTEGER(KIND=JPIB_K) :: ALLOC_STATUS
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG

  ! Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CFG_ALREADY_ALLOCATED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CFG_ALLOCATED_FLAG=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_YAML_FILE_NOT_PRESENT=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CFG_ALLOCATE_ERROR=4_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Erro handling
  PP_DEBUG_CRITICAL_COND_THROW( ASSOCIATED(VALUE%CFG_), 1 )
  PP_DEBUG_CRITICAL_COND_THROW( VALUE%IS_ALLOCATED_, 2 )

  ! Check if the file exsts
  INQUIRE( FILE=TRIM(YAML_FILE_NAME), EXIST=FILE_EXISTS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.FILE_EXISTS, 1 )

  ! Allocate the configuration
  ALLOCATE( VALUE%CFG_, STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
  PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS.NE.0, 1 )
  VALUE%IS_ALLOCATED_ = .TRUE.

  ! Load the configuration
!$omp critical(FCKIT_YAMLCONFIGURATION)
  VALUE%CFG_ = FCKIT_YAMLCONFIGURATION( FCKIT_PATHNAME( TRIM(YAML_FILE_NAME) ) )
!$omp end critical(FCKIT_YAMLCONFIGURATION)

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    CHARACTER(LEN=:), ALLOCATABLE :: STR

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_CFG_ALREADY_ALLOCATED)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Configuration already allocated' )
    CASE (ERRFLAG_CFG_ALLOCATED_FLAG)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'IS_ALLOCATED flag inconsistent with pointer allocation status' )
    CASE (ERRFLAG_YAML_FILE_NOT_PRESENT)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Unable to find the YAML file to be read: '//TRIM(ADJUSTL(YAML_FILE_NAME)) )
    CASE (ERRFLAG_CFG_ALLOCATE_ERROR)
      IF ( .NOT.ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_CREATE_ERROR_MSG( STR, 'error allocating configuration' )
      ELSE
        PP_DEBUG_CREATE_ERROR_MSG( STR, 'error allocating configuration: '//TRIM(ADJUSTL(ERRMSG)) )
        DEALLOCATE(ERRMSG)
      ENDIF
    CASE DEFAULT
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT( STR )

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point on error
  RETURN

END FUNCTION YAML_NEW_CONFIGURATION_FROM_FILE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


!>
!> @brief Deletes a configuration from a YAML configuration object.
!>
!> @section interface
!> @param [inout] CFG The YAML configuration object from which the configuration will be deleted.
!> @param [inout] HOOKS Utilities to be used for logging, debugging, tracing and option handling
!>
!> @return Integer error code (`RET`) indicating the result of the operation.
!>         Possible values:
!>           - `0`: Success
!>           - `1`: Failure
!>
!> @section Dependencies of this function:
!>
!> @subsection module dependencies
!>   - @dependency [TYPE] YAML_CONFIGURATION_T
!>
!> @subsection local dependencies
!>   - @dependency [PARAMETER] DATAKINDS_DEF_MOD::JPIB_K
!>
!> @subsection special dependencies
!>   - @dependency [*] PP_DEBUG_USE_VARS::*
!>   - @dependency [*] PP_LOG_USE_VARS::*
!>   - @dependency [*] PP_TRACE_USE_VARS::*
!>
!> @see YAML_DELETE_CONFIGURATIONS
!>
#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'YAML_DELETE_CONFIGURATION'
PP_THREAD_SAFE FUNCTION YAML_DELETE_CONFIGURATION( CFG, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  TYPE(YAML_CONFIGURATION_T), INTENT(INOUT) :: CFG
  TYPE(HOOKS_T),              INTENT(INOUT) :: HOOKS

  ! Function return value
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  INTEGER(KIND=JPIB_K) :: DEALLOC_STATUS
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG

  ! Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DEALLOC_CONFIGURATION=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  IF ( ASSOCIATED(CFG%CFG_) ) THEN
    IF ( CFG%IS_ALLOCATED_ ) THEN
!$omp critical(FCKIT_YAMLCONFIGURATION)
      CALL CFG%CFG_%FINAL()
!$omp end critical(FCKIT_YAMLCONFIGURATION)
      DEALLOCATE( CFG%CFG_, STAT=DEALLOC_STATUS, ERRMSG=ERRMSG )
      PP_DEBUG_CRITICAL_COND_THROW( DEALLOC_STATUS.NE.0, ERRFLAG_DEALLOC_CONFIGURATION )
      NULLIFY( CFG%CFG_ )
    ELSE
      NULLIFY( CFG%CFG_ )
    ENDIF
    CFG%IS_ALLOCATED_ = .FALSE.
  ENDIF

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    CHARACTER(LEN=:), ALLOCATABLE :: STR

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_DEALLOC_CONFIGURATION)
      IF ( .NOT.ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_CREATE_ERROR_MSG( STR, 'error deallocating CONFIGURATIONS' )
      ELSE
        PP_DEBUG_CREATE_ERROR_MSG( STR, 'error deallocating CONFIGURATIONS: '//TRIM(ADJUSTL(ERRMSG)) )
        DEALLOCATE(ERRMSG)
      ENDIF
    CASE DEFAULT
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT( STR )

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point on error
  RETURN

END FUNCTION YAML_DELETE_CONFIGURATION
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


!>
!> @brief Deletes configurations from a YAML configurations object.
!>
!> @section interface
!> @param [inout] CFG The YAML configurations object from which configurations will be deleted.
!> @param [inout] HOOKS Utilities to be used for logging, debugging, tracing and option handling
!>
!> @return Integer error code (`RET`) indicating the result of the operation.
!>         Possible values:
!>           - `0`: Success
!>           - `1`: Failure
!>
!> @section Dependencies of this function:
!>
!> @subsection module dependencies
!>   - @dependency [TYPE] YAML_CONFIGURATIONS_T
!>
!> @subsection local dependencies
!>   - @dependency [PARAMETER] DATAKINDS_DEF_MOD::JPIB_K
!>
!> @subsection external dependencies
!>   - @dependency [PROCEDURE] FCKIT_CONFIGURATION_MODULE::DEALLOCATE_FCKIT_CONFIGURATION
!>
!> @subsection special dependencies
!>   - @dependency [*] PP_DEBUG_USE_VARS::*
!>   - @dependency [*] PP_LOG_USE_VARS::*
!>   - @dependency [*] PP_TRACE_USE_VARS::*
!>
!> @see YAML_DELETE_CONFIGURATION
!>
#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'YAML_DELETE_CONFIGURATIONS'
PP_THREAD_SAFE FUNCTION YAML_DELETE_CONFIGURATIONS( CFG, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported from other libraries
  USE :: FCKIT_CONFIGURATION_MODULE, ONLY: DEALLOCATE_FCKIT_CONFIGURATION

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  TYPE(YAML_CONFIGURATIONS_T), INTENT(INOUT) :: CFG
  TYPE(HOOKS_T),               INTENT(INOUT) :: HOOKS

  ! Function return value
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  IF ( ALLOCATED(CFG%CFGS_) ) THEN
    CALL DEALLOCATE_FCKIT_CONFIGURATION( CFG%CFGS_ )
  ENDIF

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    CHARACTER(LEN=:), ALLOCATABLE :: STR

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE DEFAULT
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT( STR )

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point on error
  RETURN

END FUNCTION YAML_DELETE_CONFIGURATIONS
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


!>
!> @brief Retrieves a sub-configuration from a YAML configuration.
!>
!> This function extracts a specific sub-configuration from the provided YAML configuration object (`CFG`)
!> based on the given `KEY`. The extracted sub-configuration is stored in `VALUE`.
!>
!> @section interface
!> @param [in] CFG The main YAML configuration from which the sub-configuration is extracted.
!> @param [out] KEY The key identifying the sub-configuration within `CFG`.
!> @param [out] VALUE The sub-configuration extracted from `CFG` corresponding to the `KEY`.
!> @param [inout] HOOKS Utilities to be used for logging, debugging, tracing and option handling
!>
!> @return Integer error code (`RET`) indicating success or failure of the operation.
!>         Possible values:
!>           - `0`: Success
!>           - `1`: Failure
!>
!> @section Dependencies of this function:
!>
!> @subsection module dependencies
!>   - @dependency [TYPE] YAML_CONFIGURATION_T
!>
!> @subsection local dependencies
!>   - @dependency [PARAMETER] DATAKINDS_DEF_MOD::JPIB_K
!>
!> @subsection special dependencies
!>   - @dependency [*] PP_DEBUG_USE_VARS::*
!>   - @dependency [*] PP_LOG_USE_VARS::*
!>   - @dependency [*] PP_TRACE_USE_VARS::*
!>
#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'YAML_GET_SUBCONFIGURATION'
PP_THREAD_SAFE FUNCTION YAML_GET_SUBCONFIGURATION( CFG, KEY, VALUE, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  TYPE(YAML_CONFIGURATION_T), INTENT(IN)    :: CFG
  CHARACTER(LEN=*),           INTENT(IN)    :: KEY
  TYPE(YAML_CONFIGURATION_T), INTENT(OUT)   :: VALUE
  TYPE(HOOKS_T),              INTENT(INOUT) :: HOOKS

  ! Function return value
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  LOGICAL :: EX
  INTEGER(KIND=JPIB_K) :: ALLOC_STATUS
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG

  ! Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CFG_ALREADY_ALLOCATED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CFG_ALLOCATE_ERROR=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_SUBCCONFIGURATION=3_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Error handling
  PP_DEBUG_CRITICAL_COND_THROW( ASSOCIATED(VALUE%CFG_), ERRFLAG_CFG_ALREADY_ALLOCATED )

  ! Initialize the output object
  VALUE%CFG_ => NULL()
  VALUE%IS_ALLOCATED_ = .FALSE.

  ! Allocate the configuration
  ALLOCATE( VALUE%CFG_, STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
  PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS.NE.0, ERRFLAG_CFG_ALLOCATE_ERROR )

  ! Read the string
!$omp critical(FCKIT_YAMLCONFIGURATION)
  EX = CFG%CFG_%GET( KEY, VALUE%CFG_ )
!$omp end critical(FCKIT_YAMLCONFIGURATION)

  PP_DEBUG_CRITICAL_COND_THROW( .NOT.EX, ERRFLAG_UNABLE_TO_SUBCCONFIGURATION )
  VALUE%IS_ALLOCATED_ = .TRUE.

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    CHARACTER(LEN=:), ALLOCATABLE :: STR

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_CFG_ALREADY_ALLOCATED)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Configuration already associated' )
    CASE (ERRFLAG_CFG_ALLOCATE_ERROR)
      IF ( .NOT.ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_CREATE_ERROR_MSG( STR, 'error allocating configuration' )
      ELSE
        PP_DEBUG_CREATE_ERROR_MSG( STR, 'error allocating configuration: '//TRIM(ADJUSTL(ERRMSG)) )
        DEALLOCATE(ERRMSG)
      ENDIF
    CASE (ERRFLAG_UNABLE_TO_SUBCCONFIGURATION)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Unable to read subconfiguration' )
    CASE DEFAULT
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT( STR )

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point on error
  RETURN

END FUNCTION YAML_GET_SUBCONFIGURATION
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


!>
!> @brief Retrieves sub-configurations from a YAML configuration.
!>
!> This function extracts sub-configurations from the provided YAML configuration object (`CFG`),
!> based on the specified `KEY`. The extracted sub-configurations are stored in `VALUE`.
!>
!> @section interface
!> @param [in] CFG The main YAML configuration from which sub-configurations are extracted.
!> @param [out] KEY The key used to identify the sub-configurations within `CFG`.
!> @param [out] VALUE The sub-configurations extracted from `CFG` based on the `KEY`.
!> @param [inout] HOOKS Utilities to be used for logging, debugging, tracing and option handling
!>
!> @return Integer error code (`RET`) indicating success or failure of the operation.
!>         Possible values:
!>           - `0`: Success
!>           - `1`: Failure
!>
!> @section Dependencies of this function:
!>
!> @subsection module dependencies
!>   - @dependency [TYPE] YAML_CONFIGURATION_T
!>   - @dependency [TYPE] YAML_CONFIGURATIONS_T
!>
!> @subsection local dependencies
!>   - @dependency [PARAMETER] DATAKINDS_DEF_MOD::JPIB_K
!>
!> @subsection special dependencies
!>   - @dependency [*] PP_DEBUG_USE_VARS::*
!>   - @dependency [*] PP_LOG_USE_VARS::*
!>   - @dependency [*] PP_TRACE_USE_VARS::*
!>
#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'YAML_GET_SUBCONFIGURATIONS'
PP_THREAD_SAFE FUNCTION YAML_GET_SUBCONFIGURATIONS( CFG, KEY, VALUE, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  TYPE(YAML_CONFIGURATION_T),  INTENT(IN)    :: CFG
  CHARACTER(LEN=*),            INTENT(IN)    :: KEY
  TYPE(YAML_CONFIGURATIONS_T), INTENT(OUT)   :: VALUE
  TYPE(HOOKS_T),               INTENT(INOUT) :: HOOKS

  ! Function return value
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  LOGICAL :: EX

  ! Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CFG_NOT_ALLOCATED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CFGS_ALREADY_ALLOCATED=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_SUBCCONFIGURATIONS=3_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(CFG%CFG_), ERRFLAG_CFG_NOT_ALLOCATED )
  PP_DEBUG_CRITICAL_COND_THROW( ALLOCATED(VALUE%CFGS_), ERRFLAG_CFGS_ALREADY_ALLOCATED )

  ! Read the string
!$omp critical(FCKIT_YAMLCONFIGURATION)
  EX = CFG%CFG_%GET( KEY, VALUE%CFGS_ )
!$omp end critical(FCKIT_YAMLCONFIGURATION)

  PP_DEBUG_CRITICAL_COND_THROW( .NOT.EX, ERRFLAG_UNABLE_TO_SUBCCONFIGURATIONS )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    CHARACTER(LEN=:), ALLOCATABLE :: STR

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_CFG_NOT_ALLOCATED)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Configuration not allocated' )
    CASE (ERRFLAG_CFGS_ALREADY_ALLOCATED)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Configuration already allocated' )
    CASE (ERRFLAG_UNABLE_TO_SUBCCONFIGURATION)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Unable to read subconfigurations' )
    CASE DEFAULT
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT( STR )

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point on error
  RETURN

END FUNCTION YAML_GET_SUBCONFIGURATIONS
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


!>
!> @brief Retrieves the size of the YAML configurations array.
!>
!> This function calculates the size of the given array of YAML configurations (`CFG`)
!> and returns the result in `CFG_SIZE`.
!>
!> @section interface
!> @param [inout] CFG The array of YAML configurations whose size is being calculated.
!> @param [out] CFG_SIZE The size of the YAML configurations array.
!> @param [inout] HOOKS Utilities to be used for logging, debugging, tracing and option handling
!>
!> @return Integer error code (`RET`) indicating the outcome of the function.
!>         Possible values:
!>           - `0`: Success
!>           - `1`: Failure
!>
!> @section Dependencies of this function:
!>
!> @subsection module dependencies
!>   - @dependency [TYPE] YAML_CONFIGURATIONS_T
!>
!> @subsection local dependencies
!>   - @dependency [PARAMETER] DATAKINDS_DEF_MOD::JPIB_K
!>
!> @subsection special dependencies
!>   - @dependency [*] PP_DEBUG_USE_VARS::*
!>   - @dependency [*] PP_LOG_USE_VARS::*
!>   - @dependency [*] PP_TRACE_USE_VARS::*
!>
!> @section Error codes:
!>   - `ERRFLAG_CFG_ARRAY_EMPTY` (301): The configurations array is empty.
!>   - `ERRFLAG_CFG_ARRAY_CORRUPT` (302): The configurations array is corrupted or invalid.
!>
!> @see YAML_GET_CONFIGURATION_BY_ID
!>

#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'YAML_GET_CONFIGURATIONS_SIZE'
PP_THREAD_SAFE FUNCTION YAML_GET_CONFIGURATIONS_SIZE( CFG, CFG_SIZE, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  TYPE(YAML_CONFIGURATIONS_T), INTENT(INOUT) :: CFG
  INTEGER(KIND=JPIB_K),        INTENT(OUT)   :: CFG_SIZE
  TYPE(HOOKS_T),               INTENT(INOUT) :: HOOKS

  ! Function return value
  INTEGER(KIND=JPIB_K) :: RET

  ! Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CFGS_NOT_ALLOCATED=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ALLOCATED(CFG%CFGS_), ERRFLAG_CFGS_NOT_ALLOCATED )

  ! Get the configuration size
  CFG_SIZE = SIZE(CFG%CFGS_)

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    CHARACTER(LEN=:), ALLOCATABLE :: STR

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_CFGS_NOT_ALLOCATED)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Configuration not allocated' )
    CASE DEFAULT
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT( STR )

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point on error
  RETURN

END FUNCTION YAML_GET_CONFIGURATIONS_SIZE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


!>
!> @brief Retrieves a specific YAML configuration by its identifier.
!>
!> This subroutine retrieves a YAML configuration from a list of configurations (`CFG`)
!> using a specified configuration ID (`CFG_ID`). The retrieved configuration is stored
!> in `CURR_CFG`.
!>
!> @section interface
!> @param [inout] CFG The list of YAML configurations, from which one configuration is selected.
!> @param [out] CFG_ID The identifier of the YAML configuration to retrieve.
!> @param [out] CURR_CFG The YAML configuration that is retrieved based on `CFG_ID`.
!> @param [inout] HOOKS Utilities to be used for logging, debugging, tracing and option handling
!>
!> @return Integer error code (`RET`) indicating the outcome of the subroutine.
!>         Possible values:
!>           - `0`: Success
!>           - `1`: Failure
!>
!> @section Dependencies of this subroutine:
!>
!> @subsection module dependencies
!>   - @dependency [TYPE] YAML_CONFIGURATION_T
!>   - @dependency [TYPE] YAML_CONFIGURATIONS_T
!>
!> @subsection local dependencies
!>   - @dependency [PARAMETER] DATAKINDS_DEF_MOD::JPIB_K
!>
!> @subsection special dependencies
!>   - @dependency [*] PP_DEBUG_USE_VARS::*
!>   - @dependency [*] PP_LOG_USE_VARS::*
!>   - @dependency [*] PP_TRACE_USE_VARS::*
!>
!> @see YAML_GET_CONFIGURATIONS_SIZE
!>
#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'YAML_GET_CONFIGURATION_BY_ID'
PP_THREAD_SAFE FUNCTION YAML_GET_CONFIGURATION_BY_ID( CFG, CFG_ID, CURR_CFG, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  TYPE(YAML_CONFIGURATIONS_T), TARGET, INTENT(INOUT) :: CFG
  INTEGER(KIND=JPIB_K),                INTENT(IN)    :: CFG_ID
  TYPE(YAML_CONFIGURATION_T),          INTENT(OUT)   :: CURR_CFG
  TYPE(HOOKS_T),                       INTENT(INOUT) :: HOOKS

  ! Function return value
  INTEGER(KIND=JPIB_K) :: RET

  ! Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CFGS_NOT_ALLOCATED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_OUT_OF_BOUNDS_UB=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_OUT_OF_BOUNDS_LB=3_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ALLOCATED(CFG%CFGS_), ERRFLAG_CFGS_NOT_ALLOCATED )
  PP_DEBUG_CRITICAL_COND_THROW( CFG_ID.GT.SIZE(CFG%CFGS_), ERRFLAG_OUT_OF_BOUNDS_UB )
  PP_DEBUG_CRITICAL_COND_THROW( CFG_ID.LT.1, ERRFLAG_OUT_OF_BOUNDS_LB )

  ! Initialize the output object
  CURR_CFG%CFG_ => NULL()
  CURR_CFG%IS_ALLOCATED_ = .FALSE.

  ! Get the configuration
  CURR_CFG%CFG_ => CFG%CFGS_(CFG_ID)

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    CHARACTER(LEN=:), ALLOCATABLE :: STR

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_CFG_NOT_ALLOCATED)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Configuration not allocated' )
    CASE (ERRFLAG_OUT_OF_BOUNDS_UB)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Id out of bounds, bigger than the upper bound' )
    CASE (ERRFLAG_OUT_OF_BOUNDS_LB)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Id out of bounds, lower than 1' )
    CASE DEFAULT
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT( STR )

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point on error
  RETURN

END FUNCTION YAML_GET_CONFIGURATION_BY_ID
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


!>
!> @brief Checks if a specified key exists in a YAML configuration.
!>
!> This function checks if a given key (`KEY`) exists in the YAML configuration object (`CFG`).
!> It returns a logical flag (`HAS_KEY`) indicating whether the key was found.
!>
!> @section interface
!> @param [in] CFG The YAML configuration object in which the key is searched.
!> @param [in] KEY The key to search for in the YAML configuration.
!> @param [out] HAS_KEY Logical flag that indicates whether the key exists (`.TRUE.` if it exists).
!> @param [inout] HOOKS Utilities to be used for logging, debugging, tracing and option handling
!>
!> @return Integer error code (`RET`) indicating the outcome of the function.
!>         Possible values:
!>           - `0`: Success
!>           - `1`: Failure
!>
!> @section Dependencies of this function:
!>
!> @subsection module dependencies
!>   - @dependency [TYPE] YAML_CONFIGURATION_T
!>
!> @subsection local dependencies
!>   - @dependency [PARAMETER] DATAKINDS_DEF_MOD::JPIB_K
!>
#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'YAML_CONFIGURATION_HAS_KEY'
PP_THREAD_SAFE FUNCTION YAML_CONFIGURATION_HAS_KEY( CFG, KEY, HAS_KEY, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  TYPE(YAML_CONFIGURATION_T), INTENT(IN)    :: CFG
  CHARACTER(LEN=*),           INTENT(IN)    :: KEY
  LOGICAL,                    INTENT(OUT)   :: HAS_KEY
  TYPE(HOOKS_T),              INTENT(INOUT) :: HOOKS

  ! Function return value
  INTEGER(KIND=JPIB_K) :: RET

  ! Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CFG_NOT_ALLOCATED=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(CFG%CFG_), ERRFLAG_CFG_NOT_ALLOCATED )

  ! Read the string
!$omp critical(FCKIT_YAMLCONFIGURATION)
  HAS_KEY = CFG%CFG_%HAS( KEY )
!$omp end critical(FCKIT_YAMLCONFIGURATION)

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    CHARACTER(LEN=:), ALLOCATABLE :: STR

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_CFG_NOT_ALLOCATED)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Configuration not allocated' )
    CASE DEFAULT
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT( STR )

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point on error
  RETURN

END FUNCTION YAML_CONFIGURATION_HAS_KEY
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


!>
!> @brief Reads a string array from a YAML configuration.
!>
!> This function reads a string array from a provided YAML configuration object (`CFG`)
!> using the specified key (`KEY`). The `VALUE` array is populated with the parsed strings.
!> If an error occurs during the process, the function returns an error code.
!>
!> @section interface
!> @param [in] CFG The YAML configuration object from which the string array is read.
!> @param [in] KEY The key corresponding to the string array in the YAML configuration.
!> @param [out] VALUE The string array to be populated with the parsed values.
!> @param [inout] HOOKS Utilities to be used for logging, debugging, tracing and option handling
!>
!> @return Integer error code (`RET`) indicating the outcome of the function.
!>         Possible values:
!>           - `0`: Success
!>           - `1`: Failure
!>
!> @section Dependencies of this function:
!>
!> @subsection module dependencies
!>   - @dependency [TYPE] YAML_CONFIGURATION_T
!>
!> @subsection local dependencies
!>   - @dependency [PARAMETER] DATAKINDS_DEF_MOD::JPIB_K
!>
!> @subsection special dependencies
!>   - @dependency [*] PP_DEBUG_USE_VARS::*
!>   - @dependency [*] PP_LOG_USE_VARS::*
!>   - @dependency [*] PP_TRACE_USE_VARS::*
!>
!> @see YAML_READ_FLOAT
!> @see YAML_READ_INTEGER
!> @see YAML_READ_LOGICAL
!> @see YAML_READ_STRING_ARRAY
!> @see YAML_READ_INTEGER_ARRAY
!> @see YAML_READ_INTEGER_ARRAY_WITH_RANGES
!> @see YAML_READ_INTEGER_ARRAY_WITH_FILTER
!>
#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'YAML_READ_STRING_ARRAY'
PP_THREAD_SAFE FUNCTION YAML_READ_STRING_ARRAY( CFG, KEY, VALUE, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  TYPE(YAML_CONFIGURATION_T),                   INTENT(IN)    :: CFG
  CHARACTER(LEN=*),                             INTENT(IN)    :: KEY
  CHARACTER(LEN=:), ALLOCATABLE,  DIMENSION(:), INTENT(OUT)   :: VALUE
  TYPE(HOOKS_T),                                INTENT(INOUT) :: HOOKS

  ! Function return value
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  LOGICAL :: EX

  ! Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CFG_NOT_ALLOCATED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_STRING_ARRAY_ALSREADY_ALLOCATED=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_STRING_ARRAY=3_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(CFG%CFG_), ERRFLAG_CFG_NOT_ALLOCATED )
  PP_DEBUG_CRITICAL_COND_THROW( ALLOCATED(VALUE), ERRFLAG_STRING_ARRAY_ALSREADY_ALLOCATED )

  ! Read the string
!$omp critical(FCKIT_YAMLCONFIGURATION)
  EX = CFG%CFG_%GET( KEY, VALUE )
!$omp end critical(FCKIT_YAMLCONFIGURATION)
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.EX, ERRFLAG_UNABLE_TO_READ_STRING_ARRAY )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    CHARACTER(LEN=:), ALLOCATABLE :: STR

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_CFG_NOT_ALLOCATED)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Configuration not allocated' )
    CASE (ERRFLAG_STRING_ARRAY_ALSREADY_ALLOCATED)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Output string already allocated' )
    CASE (ERRFLAG_UNABLE_TO_READ_STRING_ARRAY)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Unable to read string array' )
    CASE DEFAULT
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT( STR )

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point on error
  RETURN

END FUNCTION YAML_READ_STRING_ARRAY
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


!>
!> @brief Reads an integer array from a YAML configuration with an applied filter.
!>
!> This function reads an integer array from a provided YAML configuration object (`CFG`)
!> using the specified key (`KEY`). The `VALUE` array is populated with the parsed integers,
!> applying the given filter (`FILTER`) to each element. The function returns an error code
!> indicating success or failure.
!>
!> @section interface
!> @param [in] CFG The YAML configuration object from which the integer array is read.
!> @param [in] KEY The key corresponding to the integer array in the YAML configuration.
!> @param [out] VALUE The integer array to be populated with the parsed values.
!> @param [in] FILTER A function pointer that applies a filter to each element of the array.
!> @param [inout] HOOKS Utilities to be used for logging, debugging, tracing and option handling
!>
!> @return Integer error code (`RET`) indicating the outcome of the function.
!>         Possible values:
!>           - `0`: Success
!>           - `1`: Failure
!>
!> @section Dependencies of this function:
!>
!> @subsection module dependencies
!>   - @dependency [TYPE]      YAML_CONFIGURATION_T
!>   - @dependency [INTERFACE] FUN_C2I_IF
!>
!> @subsection local dependencies
!>   - @dependency [PARAMETER] DATAKINDS_DEF_MOD::JPIB_K
!>
!> @subsection special dependencies
!>   - @dependency [*] PP_DEBUG_USE_VARS::*
!>   - @dependency [*] PP_LOG_USE_VARS::*
!>   - @dependency [*] PP_TRACE_USE_VARS::*
!>
!> @see YAML_READ_STRING
!> @see YAML_READ_FLOAT
!> @see YAML_READ_INTEGER
!> @see YAML_READ_LOGICAL
!> @see YAML_READ_STRING_ARRAY
!> @see YAML_READ_INTEGER_ARRAY
!> @see YAML_READ_INTEGER_ARRAY_WITH_RANGES
!>
#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'YAML_READ_INTEGER_ARRAY_WITH_FILTER'
PP_THREAD_SAFE FUNCTION YAML_READ_INTEGER_ARRAY_WITH_FILTER( CFG, KEY, VALUE, FILTER, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  TYPE(YAML_CONFIGURATION_T),                       INTENT(IN)    :: CFG
  CHARACTER(LEN=*),                                 INTENT(IN)    :: KEY
  INTEGER(KIND=JPIB_K), ALLOCATABLE,  DIMENSION(:), INTENT(OUT)   :: VALUE
  PROCEDURE(FUN_C2I_IF), POINTER,                   INTENT(IN)    :: FILTER
  TYPE(HOOKS_T),                                    INTENT(INOUT) :: HOOKS

  ! Function return value
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  INTEGER(KIND=JPIB_K) :: I
  CHARACTER(LEN=:), ALLOCATABLE, DIMENSION(:) :: ATMP
  INTEGER(KIND=JPIB_K) :: VALUE_SIZE
  INTEGER(KIND=JPIB_K) :: ALLOC_STATUS
  INTEGER(KIND=JPIB_K) :: DEALLOC_STATUS
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG

  ! Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CFG_NOT_ALLOCATED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_VALUE_ALREADY_ALLOCATED=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_STRING_ARRAY_NOT_ALLOCATED=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_STRING_ARRAY_SIZE_LT_1=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ALLOCATION_ERROR=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CALL_FILTER=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DEALLOCATION_ERROR=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ERROR_CALL_READ_STRING_ARRAY=8_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(CFG%CFG_), ERRFLAG_CFG_NOT_ALLOCATED )
  PP_DEBUG_CRITICAL_COND_THROW( ALLOCATED(VALUE),          ERRFLAG_VALUE_ALREADY_ALLOCATED )

  ! Read the paramId as a string array
  PP_TRYCALL(ERRFLAG_ERROR_CALL_READ_STRING_ARRAY) YAML_READ_STRING_ARRAY( CFG, KEY, ATMP, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ALLOCATED(ATMP), ERRFLAG_STRING_ARRAY_NOT_ALLOCATED )
  PP_DEBUG_CRITICAL_COND_THROW( SIZE(ATMP).LT.1, ERRFLAG_STRING_ARRAY_SIZE_LT_1 )

  ! Allocate the paramId array
  VALUE_SIZE = SIZE(ATMP)
  ALLOCATE( VALUE(VALUE_SIZE), STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
  PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS.NE.0, ERRFLAG_ALLOCATION_ERROR )

  ! Compute the size of the paramId array
  ParamIdFIlterSizeLoop: DO I = 1, VALUE_SIZE

    ! Filter the value
    PP_TRYCALL(ERRFLAG_CALL_FILTER) FILTER(ATMP(I), VALUE(I), HOOKS )

  ENDDO ParamIdFIlterSizeLoop

  ! Deallocate temporary memory
  IF ( ALLOCATED(ATMP) ) THEN
    DEALLOCATE( ATMP, STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
    PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS.NE.0, ERRFLAG_DEALLOCATION_ERROR )
  ENDIF

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    CHARACTER(LEN=:), ALLOCATABLE :: STR

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_CFG_NOT_ALLOCATED)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'YAML configuration not allocated' )
    CASE (ERRFLAG_VALUE_ALREADY_ALLOCATED)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'VALUE already allocated' )
    CASE (ERRFLAG_STRING_ARRAY_NOT_ALLOCATED)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'String array not allocated after read' )
    CASE (ERRFLAG_STRING_ARRAY_SIZE_LT_1)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'String array is empty' )
    CASE (ERRFLAG_ALLOCATION_ERROR)
      IF ( .NOT.ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_CREATE_ERROR_MSG( STR, 'error allocating VALUES' )
      ELSE
        PP_DEBUG_CREATE_ERROR_MSG( STR, 'error allocating VALUES: '//TRIM(ADJUSTL(ERRMSG)) )
        DEALLOCATE(ERRMSG)
      ENDIF
    CASE (ERRFLAG_CALL_FILTER)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'error calling filter' )
    CASE (ERRFLAG_DEALLOCATION_ERROR)
      IF ( .NOT.ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_CREATE_ERROR_MSG( STR, 'error deallocating ATMP' )
      ELSE
        PP_DEBUG_CREATE_ERROR_MSG( STR, 'error deallocating ATMP: '//TRIM(ADJUSTL(ERRMSG)) )
        DEALLOCATE(ERRMSG)
      ENDIF
    CASE (ERRFLAG_ERROR_CALL_READ_STRING_ARRAY)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'error calling YAML_READ_STRING_ARRAY' )
    CASE DEFAULT
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT( STR )

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point on error
  RETURN

END FUNCTION YAML_READ_INTEGER_ARRAY_WITH_FILTER
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


!>
!> @brief Reads an integer array with ranges from a YAML configuration.
!>
!> This function reads an integer array from a provided YAML configuration object (`CFG`)
!> using the specified key (`KEY`). The `VALUE` array is populated with the parsed integers,
!> supporting ranges in the YAML configuration. The function returns an error code indicating
!> success or failure of the operation. If verbose mode is enabled, additional output is generated
!> for debugging purposes.
!>
!> @section interface
!> @param [in] CFG The YAML configuration object from which the integer array is read.
!> @param [in] KEY The key corresponding to the integer array in the YAML configuration.
!> @param [out] VALUE The integer array to be populated with the parsed values, supporting ranges.
!> @param [inout] HOOKS Utilities to be used for logging, debugging, tracing and option handling
!>
!> @return Integer error code (`RET`) indicating the outcome of the function.
!>         Possible values:
!>           - `0`: Success
!>           - `1`: Failure
!>
!> @section Dependencies of this function:
!>
!> @subsection module dependencies
!>   - @dependency [TYPE]      YAML_CONFIGURATION_T
!>   - @dependency [PROCEDURE] YAML_READ_STRING_ARRAY
!>   - @dependency [PROCEDURE] STRING_IS_INTEGER
!>   - @dependency [PROCEDURE] STRING_IS_INTEGER_RANGE
!>   - @dependency [PROCEDURE] STRING_IS_INTEGER_RANGE_BY
!>   - @dependency [PROCEDURE] STRING_TO_INTEGER
!>   - @dependency [PROCEDURE] STRING_TO_INTEGER_RANGE
!>   - @dependency [PROCEDURE] STRING_TO_INTEGER_RANGE_BY
!>
!> @subsection local dependencies
!>   - @dependency [PARAMETER] DATAKINDS_DEF_MOD::JPIB_K
!>
!> @subsection special dependencies
!>   - @dependency [*] PP_DEBUG_USE_VARS::*
!>   - @dependency [*] PP_LOG_USE_VARS::*
!>   - @dependency [*] PP_TRACE_USE_VARS::*
!>
!> @see YAML_READ_STRING_ARRAY
!> @see YAML_READ_INTEGER_ARRAY
!> @see YAML_READ_INTEGER_ARRAY_WITH_FILTER
!> @see YAML_READ_STRING
!> @see YAML_READ_FLOAT
!> @see YAML_READ_LOGICAL
!> @see YAML_READ_INTEGER
!>
#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'YAML_READ_INTEGER_ARRAY_WITH_RANGES'
PP_THREAD_SAFE FUNCTION YAML_READ_INTEGER_ARRAY_WITH_RANGES( CFG, KEY, VALUE, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  TYPE(YAML_CONFIGURATION_T),                       INTENT(IN)    :: CFG
  CHARACTER(LEN=*),                                 INTENT(IN)    :: KEY
  INTEGER(KIND=JPIB_K), ALLOCATABLE,  DIMENSION(:), INTENT(OUT)   :: VALUE
  TYPE(HOOKS_T),                                    INTENT(INOUT) :: HOOKS

  ! Function return value
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  CHARACTER(LEN=:), ALLOCATABLE, DIMENSION(:) :: ATMP
  INTEGER(KIND=JPIB_K) :: I
  INTEGER(KIND=JPIB_K) :: J
  LOGICAL :: IS_INTEGER
  LOGICAL :: IS_INTEGER_RANGE
  LOGICAL :: IS_INTEGER_RANGE_BY
  INTEGER(KIND=JPIB_K) :: LO
  INTEGER(KIND=JPIB_K) :: HI
  INTEGER(KIND=JPIB_K) :: BY
  INTEGER(KIND=JPIB_K) :: VALUE_SIZE
  INTEGER(KIND=JPIB_K) :: ALLOC_STATUS
  INTEGER(KIND=JPIB_K) :: DEALLOC_STATUS
  CHARACTER(LEN=:), ALLOCATABLE :: ERRMSG


  ! Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CFG_NOT_ALLOCATED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_STRING_ARRAY_NOT_ALLOCATED=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_STRING_ARRAY_SIZE_LT_1=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_STRING_IN_ARRAY_1=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_STRING_IN_ARRAY_2=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_STRING_IN_ARRAY_3=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_STRING_IN_ARRAY_4=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_STRING_IN_ARRAY_5=8_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ALLOCATION_ERROR=10_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_VALUE_OUT_OF_BOUNDS=12_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_DEALLOCATION_ERROR=13_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_VALUS_SIZE_LT_1=14_JPIB_K

  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ERROR_CALL_READ_STRING_ARRAY=15_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ERROR_CALL_STRING_IS_INTEGER=16_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ERROR_CALL_STRING_IS_INTEGER_RANGE=17_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ERROR_CALL_STRING_IS_INTEGER_RANGE_BY=18_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ERROR_CALL_STRING_TO_INTEGER=19_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ERROR_CALL_STRING_TO_INTEGER_RANGE=20_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_ERROR_CALL_STRING_TO_INTEGER_RANGE_BY=21_JPIB_K


  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(CFG%CFG_), ERRFLAG_CFG_NOT_ALLOCATED )

  ! Read the paramId as a string array
  PP_TRYCALL(ERRFLAG_ERROR_CALL_READ_STRING_ARRAY) YAML_READ_STRING_ARRAY( CFG, KEY, ATMP, HOOKS )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ALLOCATED(ATMP), ERRFLAG_STRING_ARRAY_NOT_ALLOCATED )
  PP_DEBUG_CRITICAL_COND_THROW( SIZE(ATMP).LT.1, ERRFLAG_STRING_ARRAY_SIZE_LT_1 )

  ! Compute the size of the paramId array
  VALUE_SIZE = 0_JPIB_K
  ParamIdFIlterSizeLoop: DO I = 1, SIZE(ATMP)

    ! Check if the value is an integer
    PP_TRYCALL(ERRFLAG_ERROR_CALL_STRING_IS_INTEGER) STRING_IS_INTEGER         ( ATMP(I), IS_INTEGER, HOOKS )
    PP_TRYCALL(ERRFLAG_ERROR_CALL_STRING_IS_INTEGER_RANGE) STRING_IS_INTEGER_RANGE   ( ATMP(I), IS_INTEGER_RANGE, HOOKS )
    PP_TRYCALL(ERRFLAG_ERROR_CALL_STRING_IS_INTEGER_RANGE_BY) STRING_IS_INTEGER_RANGE_BY( ATMP(I), IS_INTEGER_RANGE_BY, HOOKS )
    PP_DEBUG_CRITICAL_COND_THROW( .NOT.IS_INTEGER .AND. .NOT.IS_INTEGER_RANGE .AND. .NOT.IS_INTEGER_RANGE_BY, ERRFLAG_INVALID_STRING_IN_ARRAY_1 )
    PP_DEBUG_CRITICAL_COND_THROW( IS_INTEGER .AND. IS_INTEGER_RANGE .AND. IS_INTEGER_RANGE_BY, ERRFLAG_INVALID_STRING_IN_ARRAY_2 )

    PP_DEBUG_CRITICAL_COND_THROW( IS_INTEGER .AND. IS_INTEGER_RANGE, ERRFLAG_INVALID_STRING_IN_ARRAY_3 )
    PP_DEBUG_CRITICAL_COND_THROW( IS_INTEGER .AND. IS_INTEGER_RANGE_BY, ERRFLAG_INVALID_STRING_IN_ARRAY_4 )
    PP_DEBUG_CRITICAL_COND_THROW( IS_INTEGER_RANGE .AND. IS_INTEGER_RANGE_BY, ERRFLAG_INVALID_STRING_IN_ARRAY_5 )

    ! Update the total size of the paramId array
    IF ( IS_INTEGER ) THEN
      VALUE_SIZE = VALUE_SIZE + 1
    ELSE IF ( IS_INTEGER_RANGE ) THEN
      PP_TRYCALL(ERRFLAG_ERROR_CALL_STRING_TO_INTEGER_RANGE) STRING_TO_INTEGER_RANGE( ATMP(I), LO, HI, HOOKS )
      VALUE_SIZE = VALUE_SIZE + HI - LO + 1
    ELSE IF ( IS_INTEGER_RANGE_BY ) THEN
      PP_TRYCALL(ERRFLAG_ERROR_CALL_STRING_TO_INTEGER_RANGE_BY) STRING_TO_INTEGER_RANGE_BY( ATMP(I), LO, HI, BY, HOOKS )
      VALUE_SIZE = VALUE_SIZE + (HI - LO + 1)/BY
    ENDIF

  ENDDO ParamIdFIlterSizeLoop
  PP_DEBUG_CRITICAL_COND_THROW( VALUE_SIZE.LT.1, ERRFLAG_VALUS_SIZE_LT_1 )

  ! Allocate the paramId array
  ALLOCATE( VALUE(VALUE_SIZE), STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
  PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS.NE.0, ERRFLAG_ALLOCATION_ERROR )

  ! Fill the paramId array
  J = 0_JPIB_K
  ParamIdFIlterFillLoop: DO I = 1, SIZE(ATMP)

    ! Check if the value is an integer
    PP_TRYCALL(ERRFLAG_ERROR_CALL_STRING_IS_INTEGER) STRING_IS_INTEGER( ATMP(I), IS_INTEGER, HOOKS )
    PP_TRYCALL(ERRFLAG_ERROR_CALL_STRING_IS_INTEGER_RANGE) STRING_IS_INTEGER_RANGE( ATMP(I), IS_INTEGER_RANGE, HOOKS )
    PP_TRYCALL(ERRFLAG_ERROR_CALL_STRING_IS_INTEGER_RANGE_BY) STRING_IS_INTEGER_RANGE_BY( ATMP(I), IS_INTEGER_RANGE_BY, HOOKS )
    PP_DEBUG_CRITICAL_COND_THROW( .NOT.IS_INTEGER .AND. .NOT.IS_INTEGER_RANGE .AND. .NOT.IS_INTEGER_RANGE_BY, ERRFLAG_INVALID_STRING_IN_ARRAY_1 )
    PP_DEBUG_CRITICAL_COND_THROW( IS_INTEGER .AND. IS_INTEGER_RANGE .AND. IS_INTEGER_RANGE_BY, ERRFLAG_INVALID_STRING_IN_ARRAY_2 )

    PP_DEBUG_CRITICAL_COND_THROW( IS_INTEGER .AND. IS_INTEGER_RANGE, ERRFLAG_INVALID_STRING_IN_ARRAY_3 )
    PP_DEBUG_CRITICAL_COND_THROW( IS_INTEGER .AND. IS_INTEGER_RANGE_BY, ERRFLAG_INVALID_STRING_IN_ARRAY_4 )
    PP_DEBUG_CRITICAL_COND_THROW( IS_INTEGER_RANGE .AND. IS_INTEGER_RANGE_BY, ERRFLAG_INVALID_STRING_IN_ARRAY_5 )


    ! Update the total size of the paramId array
    IF ( IS_INTEGER ) THEN

      ! Fill the paramId array when the item is an integer (e.g., 1)
      J = J + 1
      PP_DEBUG_CRITICAL_COND_THROW( J.GT.SIZE(VALUE), ERRFLAG_VALUE_OUT_OF_BOUNDS )
      PP_TRYCALL(ERRFLAG_ERROR_CALL_STRING_TO_INTEGER) STRING_TO_INTEGER( ATMP(I), VALUE(J), HOOKS )

    ELSE IF ( IS_INTEGER_RANGE ) THEN

      ! Fill the paramId array when the item is an integer range (e.g., 1:10)
      PP_TRYCALL(ERRFLAG_ERROR_CALL_STRING_TO_INTEGER_RANGE) STRING_TO_INTEGER_RANGE( ATMP(I), LO, HI, HOOKS )
      ParamIdFIlterFillRangeLoop: DO
        J = J + 1
        PP_DEBUG_CRITICAL_COND_THROW( J.GT.SIZE(VALUE), ERRFLAG_VALUE_OUT_OF_BOUNDS )
        VALUE(J) = LO
        IF ( LO .EQ. HI ) THEN
          EXIT ParamIdFIlterFillRangeLoop
        ENDIF
        LO = LO + 1
      ENDDO ParamIdFIlterFillRangeLoop

    ELSE IF ( IS_INTEGER_RANGE_BY ) THEN

      ! Fill the paramId array when the item is an integer range by (e.g., 1:10:2)
      PP_TRYCALL(ERRFLAG_ERROR_CALL_STRING_TO_INTEGER_RANGE_BY) STRING_TO_INTEGER_RANGE_BY( ATMP(I), LO, HI, BY, HOOKS )
      ParamIdFIlterFillRangeByLoop: DO
        J = J + 1
        PP_DEBUG_CRITICAL_COND_THROW( J.GT.SIZE(VALUE), ERRFLAG_VALUE_OUT_OF_BOUNDS )
        VALUE(J) = LO
        IF ( LO .EQ. HI ) THEN
          EXIT ParamIdFIlterFillRangeByLoop
        ENDIF
        LO = LO + BY
      ENDDO ParamIdFIlterFillRangeByLoop

    ENDIF

  ENDDO ParamIdFIlterFillLoop

  ! Deallocate temporary memory
  IF ( ALLOCATED(ATMP) ) THEN
    DEALLOCATE( ATMP, STAT=ALLOC_STATUS, ERRMSG=ERRMSG )
    PP_DEBUG_CRITICAL_COND_THROW( ALLOC_STATUS.NE.0, ERRFLAG_DEALLOCATION_ERROR )
  ENDIF

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    CHARACTER(LEN=:), ALLOCATABLE :: STR

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE(ERRFLAG_CFG_NOT_ALLOCATED)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'YAML configuration not allocated' )
    CASE(ERRFLAG_STRING_ARRAY_NOT_ALLOCATED)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'String array not allocated after read' )
    CASE(ERRFLAG_STRING_ARRAY_SIZE_LT_1)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'String array is empty' )
    CASE(ERRFLAG_INVALID_STRING_IN_ARRAY_1)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Error parsing string no matches (no integer, no integer range, no integer range by)' )
    CASE(ERRFLAG_INVALID_STRING_IN_ARRAY_2)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Error parsing string multiple matches ( integer, integer range, integer range by)' )
    CASE(ERRFLAG_INVALID_STRING_IN_ARRAY_3)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Error parsing string multiple matches (integer, integer range)' )
    CASE(ERRFLAG_INVALID_STRING_IN_ARRAY_4)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Error parsing string multiple matches (integer, integer range by)' )
    CASE(ERRFLAG_INVALID_STRING_IN_ARRAY_5)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Error parsing string multiple matches (integer range, integer range by)' )
    CASE(ERRFLAG_ALLOCATION_ERROR)
      IF ( .NOT.ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_CREATE_ERROR_MSG( STR, 'error allocating VALUES' )
      ELSE
        PP_DEBUG_CREATE_ERROR_MSG( STR, 'error allocating VALUES: '//TRIM(ADJUSTL(ERRMSG)) )
        DEALLOCATE(ERRMSG)
      ENDIF
    CASE(ERRFLAG_VALUE_OUT_OF_BOUNDS)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Out of bounds while setting integer value to the output array' )
    CASE(ERRFLAG_DEALLOCATION_ERROR)
      IF ( .NOT.ALLOCATED(ERRMSG) ) THEN
        PP_DEBUG_CREATE_ERROR_MSG( STR, 'error deallocating ATMP' )
      ELSE
        PP_DEBUG_CREATE_ERROR_MSG( STR, 'error deallocating ATMP: '//TRIM(ADJUSTL(ERRMSG)) )
        DEALLOCATE(ERRMSG)
      ENDIF
    CASE (ERRFLAG_VALUS_SIZE_LT_1)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Value size is less than 1 after parsing all the elements' )
    CASE (ERRFLAG_ERROR_CALL_READ_STRING_ARRAY)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'error calling YAML_READ_STRING_ARRAY' )
    CASE (ERRFLAG_ERROR_CALL_STRING_IS_INTEGER)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'error calling STRING_IS_INTEGER' )
    CASE (ERRFLAG_ERROR_CALL_STRING_IS_INTEGER_RANGE)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'error calling STRING_IS_INTEGER_RANGE' )
    CASE (ERRFLAG_ERROR_CALL_STRING_IS_INTEGER_RANGE_BY)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'error calling STRING_IS_INTEGER_RANGE_BY' )
    CASE (ERRFLAG_ERROR_CALL_STRING_TO_INTEGER)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'error calling STRING_TO_INTEGER' )
    CASE (ERRFLAG_ERROR_CALL_STRING_TO_INTEGER_RANGE) 
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'error calling STRING_TO_INTEGER_RANGE' )
    CASE (ERRFLAG_ERROR_CALL_STRING_TO_INTEGER_RANGE_BY)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'error calling STRING_TO_INTEGER_RANGE_BY' )
    CASE DEFAULT
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT( STR )

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point on error
  RETURN

END FUNCTION YAML_READ_INTEGER_ARRAY_WITH_RANGES
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


!>
!> @brief Reads an integer array from a YAML configuration.
!>
!> This function reads an integer array from a provided YAML configuration object (`CFG`)
!> using the specified key (`KEY`). The `VALUE` array is populated with the parsed integers.
!> If an error occurs during the reading process, the function returns an error code.
!>
!> @section interface
!> @param [in] CFG The YAML configuration object from which the integer array is read.
!> @param [in] KEY The key corresponding to the integer array in the YAML configuration.
!> @param [out] VALUE The integer array to be populated with the parsed values.
!> @param [inout] HOOKS Utilities to be used for logging, debugging, tracing and option handling
!>
!> @return Integer error code (`RET`) indicating the outcome of the function.
!>         Possible values:
!>           - `0`: Success
!>           - `1`: Failure
!>
!> @section Dependencies of this function:
!>
!> @subsection module dependencies
!>   - @dependency [TYPE] YAML_CONFIGURATION_T
!>
!> @subsection local dependencies
!>   - @dependency [PARAMETER] DATAKINDS_DEF_MOD::JPIB_K
!>
!> @subsection special dependencies
!>   - @dependency [*] PP_DEBUG_USE_VARS::*
!>   - @dependency [*] PP_LOG_USE_VARS::*
!>   - @dependency [*] PP_TRACE_USE_VARS::*
!>
#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'YAML_READ_INTEGER_ARRAY'
PP_THREAD_SAFE FUNCTION YAML_READ_INTEGER_ARRAY( CFG, KEY, VALUE, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  TYPE(YAML_CONFIGURATION_T),                       INTENT(IN)    :: CFG
  CHARACTER(LEN=*),                                 INTENT(IN)    :: KEY
  INTEGER(KIND=JPIB_K), ALLOCATABLE,  DIMENSION(:), INTENT(OUT)   :: VALUE
  TYPE(HOOKS_T),                                    INTENT(INOUT) :: HOOKS

  ! Function return value
  INTEGER(KIND=JPIB_K) :: RET

  ! Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CFG_NOT_ALLOCATED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_INTEGER_ARRAY=2_JPIB_K


  ! Local variables
  LOGICAL :: EX

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(CFG%CFG_), ERRFLAG_CFG_NOT_ALLOCATED )

  ! Read the string
!$omp critical(FCKIT_YAMLCONFIGURATION)
  EX = CFG%CFG_%GET( KEY, VALUE )
!$omp end critical(FCKIT_YAMLCONFIGURATION)
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.EX, ERRFLAG_UNABLE_TO_READ_INTEGER_ARRAY )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    CHARACTER(LEN=:), ALLOCATABLE :: STR

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_CFG_NOT_ALLOCATED)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Configuration not allocated' )
    CASE (ERRFLAG_UNABLE_TO_READ_INTEGER_ARRAY)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Unable to read integer array' )
    CASE DEFAULT
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT( STR )

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point on error
  RETURN

END FUNCTION YAML_READ_INTEGER_ARRAY
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE



!>
!> @brief Reads a string value from a YAML configuration object.
!>
!> This function retrieves a string value from the specified YAML configuration (`CFG`)
!> using the given key (`KEY`) and assigns the result to the output variable (`VALUE`).
!>
!> @section interface
!>
!> @param [in] CFG The YAML configuration object from which the string value is read.
!> @param [in] KEY The key used to extract the string value from the configuration.
!> @param [out] VALUE The string value extracted from the configuration, which is allocated
!>                     dynamically.
!> @param [inout] HOOKS Utilities to be used for logging, debugging, tracing and option handling
!>
!> @return Integer error code (`RET`) indicating success or failure of the operation:
!>   - `0`: Success
!>   - `1`: Failure
!>
!> @section Dependencies of this function:
!>
!> @subsection module dependencies
!>   - @dependency [TYPE] YAML_CONFIGURATION_T
!>
!> @subsection special dependencies
!>   - @dependency [*] PP_DEBUG_USE_VARS::*
!>   - @dependency [*] PP_LOG_USE_VARS::*
!>   - @dependency [*] PP_TRACE_USE_VARS::*
!>
!> @see YAML_READ_FLOAT
!> @see YAML_READ_INTEGER
!> @see YAML_READ_LOGICAL
!> @see YAML_READ_STRING_ARRAY
!> @see YAML_READ_INTEGER_ARRAY
!> @see YAML_READ_INTEGER_ARRAY_WITH_RANGES
!> @see YAML_READ_INTEGER_ARRAY_WITH_FILTER
!>
#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'YAML_READ_STRING'
PP_THREAD_SAFE FUNCTION YAML_READ_STRING( CFG, KEY, VALUE, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  TYPE(YAML_CONFIGURATION_T),    INTENT(IN)    :: CFG
  CHARACTER(LEN=*),              INTENT(IN)    :: KEY
  CHARACTER(LEN=:), ALLOCATABLE, INTENT(OUT)   :: VALUE
  TYPE(HOOKS_T),                 INTENT(INOUT) :: HOOKS

  ! Function return value
  INTEGER(KIND=JPIB_K) :: RET

  ! Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CFG_NOT_ALLOCATED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_STRING=2_JPIB_K

  ! Local variables
  LOGICAL :: EX

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(CFG%CFG_), ERRFLAG_CFG_NOT_ALLOCATED )

  ! Read the string
!$omp critical(FCKIT_YAMLCONFIGURATION)
  EX = CFG%CFG_%GET( KEY, VALUE )
!$omp end critical(FCKIT_YAMLCONFIGURATION)
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.EX, ERRFLAG_UNABLE_TO_READ_STRING )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    CHARACTER(LEN=:), ALLOCATABLE :: STR

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_CFG_NOT_ALLOCATED)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Configuration not allocated' )
    CASE (ERRFLAG_UNABLE_TO_READ_STRING)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Unable to read string from configuration' )
    CASE DEFAULT
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT( STR )

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point on error
  RETURN

END FUNCTION YAML_READ_STRING
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


!>
!> @brief Reads an integer value from a YAML configuration object.
!>
!> This function retrieves an integer value from the specified YAML configuration (`CFG`)
!> using the given key (`KEY`) and assigns the result to the output variable (`VALUE`).
!>
!> @section interface
!>
!> @param [in] CFG The YAML configuration object from which the integer value is read.
!> @param [in] KEY The key used to extract the integer value from the configuration.
!> @param [out] VALUE The integer value extracted from the configuration.
!> @param [inout] HOOKS Utilities to be used for logging, debugging, tracing and option handling
!>
!> @return Integer error code (`RET`) indicating success or failure of the operation:
!>   - `0`: Success
!>   - `1`: Failure
!>
!> @section Dependencies of this function:
!>
!> @subsection module dependencies
!>   - @dependency [TYPE] YAML_CONFIGURATION_T
!>
!> @subsection local dependencies
!>   - @dependency [PARAMETER] DATAKINDS_DEF_MOD::JPIB_K
!>
!> @subsection special dependencies
!>   - @dependency [*] PP_DEBUG_USE_VARS::*
!>   - @dependency [*] PP_LOG_USE_VARS::*
!>   - @dependency [*] PP_TRACE_USE_VARS::*
!>
!> @see YAML_READ_FLOAT
!> @see YAML_READ_LOGICAL
!> @see YAML_READ_STRING
!> @see YAML_READ_STRING_ARRAY
!> @see YAML_READ_INTEGER_ARRAY
!> @see YAML_READ_INTEGER_ARRAY_WITH_RANGES
!> @see YAML_READ_INTEGER_ARRAY_WITH_FILTER
!>
#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'YAML_READ_INTEGER'
PP_THREAD_SAFE FUNCTION YAML_READ_INTEGER( CFG, KEY, VALUE, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  TYPE(YAML_CONFIGURATION_T), INTENT(IN)    :: CFG
  CHARACTER(LEN=*),           INTENT(IN)    :: KEY
  INTEGER(KIND=JPIB_K),       INTENT(OUT)   :: VALUE
  TYPE(HOOKS_T),              INTENT(INOUT) :: HOOKS

  ! Function return value
  INTEGER(KIND=JPIB_K) :: RET

  ! Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CFG_NOT_ALLOCATED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_INTEGER=2_JPIB_K

  ! Local variables
  LOGICAL :: EX

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(CFG%CFG_), ERRFLAG_CFG_NOT_ALLOCATED )

  ! Read the string
!$omp critical(FCKIT_YAMLCONFIGURATION)
  EX = CFG%CFG_%GET( KEY, VALUE )
!$omp end critical(FCKIT_YAMLCONFIGURATION)
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.EX, ERRFLAG_UNABLE_TO_READ_INTEGER )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    CHARACTER(LEN=:), ALLOCATABLE :: STR

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_CFG_NOT_ALLOCATED)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Configuration not allocated' )
    CASE (ERRFLAG_UNABLE_TO_READ_INTEGER)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Unable to read integer from configuration' )
    CASE DEFAULT
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT( STR )

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point on error
  RETURN

END FUNCTION YAML_READ_INTEGER
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


!>
!> @brief Reads a floating-point value from a YAML configuration object.
!>
!> This function reads a floating-point value from the provided YAML configuration (`CFG`)
!> using the specified key (`KEY`) and assigns the result to the output variable (`VALUE`).
!> If an error occurs during the reading process, an appropriate error code is returned.
!>
!> @section interface
!>
!> @param [in] CFG The YAML configuration object from which the floating-point value is read.
!> @param [in] KEY The key used to retrieve the floating-point value from the configuration.
!> @param [out] VALUE The floating-point value extracted from the configuration.
!> @param [inout] HOOKS Utilities to be used for logging, debugging, tracing and option handling
!>
!> @return Integer error code (`RET`) indicating success or failure of the operation:
!>   - `0`: Success
!>   - `1`: Failure
!>
!> @section Dependencies of this function:
!>
!> @subsubsection module dependencies
!>   - @dependency [PROCEDURE] READ_INTEGER_PATTERNS
!>
!> @subsection module dependencies
!>   - @dependency [PARAMETER] DATAKINDS_DEF_MOD::JPRD_K
!>
!> @subsection special dependencies
!>   - @dependency [*] PP_DEBUG_USE_VARS::*
!>   - @dependency [*] PP_LOG_USE_VARS::*
!>   - @dependency [*] PP_TRACE_USE_VARS::*
!>
!> @see YAML_READ_LOGICAL
!> @see YAML_READ_INTEGER
!> @see YAML_READ_STRING
!> @see YAML_READ_STRING_ARRAY
!> @see YAML_READ_INTEGER_ARRAY
!> @see YAML_READ_INTEGER_ARRAY_WITH_RANGES
!> @see YAML_READ_INTEGER_ARRAY_WITH_FILTER
!>
#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'YAML_READ_FLOAT'
PP_THREAD_SAFE FUNCTION YAML_READ_FLOAT( CFG, KEY, VALUE, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: DATAKINDS_DEF_MOD, ONLY: JPRD_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  TYPE(YAML_CONFIGURATION_T), INTENT(IN)    :: CFG
  CHARACTER(LEN=*),           INTENT(IN)    :: KEY
  REAL(KIND=JPRD_K),          INTENT(OUT)   :: VALUE
  TYPE(HOOKS_T),              INTENT(INOUT) :: HOOKS

  ! Function return value
  INTEGER(KIND=JPIB_K) :: RET

  ! Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CFG_NOT_ALLOCATED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_FLOAT=2_JPIB_K

  ! Local variables
  LOGICAL :: EX

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(CFG%CFG_), ERRFLAG_CFG_NOT_ALLOCATED )

  ! Read the string
!$omp critical(FCKIT_YAMLCONFIGURATION)
  EX = CFG%CFG_%GET( KEY, VALUE )
!$omp end critical(FCKIT_YAMLCONFIGURATION)
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.EX, ERRFLAG_UNABLE_TO_READ_FLOAT )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    CHARACTER(LEN=:), ALLOCATABLE :: STR

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_CFG_NOT_ALLOCATED)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Configuration not allocated' )
    CASE (ERRFLAG_UNABLE_TO_READ_FLOAT)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Unable to read float from configuration' )
    CASE DEFAULT
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT( STR )

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point on error
  RETURN

END FUNCTION YAML_READ_FLOAT
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


!>
!> @brief Reads a logical (boolean) value from a YAML configuration object.
!>
!> This function reads a logical (`TRUE` or `FALSE`) value from the provided YAML
!> configuration (`CFG`) and assigns it to the output logical variable (`VALUE`).
!> If an error occurs, it returns an appropriate error code.
!>
!> @section interface
!>
!> @param [in] CFG The YAML configuration object from which the logical value is read.
!> @param [in] KEY The key used to extract the logical value from the configuration.
!> @param [out] VALUE The logical value extracted from the configuration.
!> @param [inout] HOOKS Utilities to be used for logging, debugging, tracing and option handling
!>
!> @return Integer error code (`RET`) indicating success or failure of the operation:
!>   - `0`: Success
!>   - `1`: Failure
!>
!> @section Dependencies of this function:
!>
!> @subsection module dependencies
!>   - @dependency [TYPE] YAML_CONFIGURATION_T
!>
!> @subsection special dependencies
!>   - @dependency [*] PP_DEBUG_USE_VARS::*
!>   - @dependency [*] PP_LOG_USE_VARS::*
!>   - @dependency [*] PP_TRACE_USE_VARS::*
!>
!> @see YAML_READ_FLOAT
!> @see YAML_READ_INTEGER
!> @see YAML_READ_STRING
!> @see YAML_READ_STRING_ARRAY
!> @see YAML_READ_INTEGER_ARRAY
!> @see YAML_READ_INTEGER_ARRAY_WITH_RANGES
!> @see YAML_READ_INTEGER_ARRAY_WITH_FILTER
!>
#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'YAML_READ_LOGICAL'
PP_THREAD_SAFE FUNCTION YAML_READ_LOGICAL( CFG, KEY, VALUE, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  TYPE(YAML_CONFIGURATION_T), INTENT(IN)    :: CFG
  CHARACTER(LEN=*),           INTENT(IN)    :: KEY
  LOGICAL,                    INTENT(OUT)   :: VALUE
  TYPE(HOOKS_T),              INTENT(INOUT) :: HOOKS

  ! Function return value
  INTEGER(KIND=JPIB_K) :: RET

  ! Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_CFG_NOT_ALLOCATED=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNABLE_TO_READ_LOGICAL=2_JPIB_K

  ! Local variables
  LOGICAL :: EX

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Error handling
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.ASSOCIATED(CFG%CFG_), ERRFLAG_CFG_NOT_ALLOCATED )

  ! Read the string
!$omp critical(FCKIT_YAMLCONFIGURATION)
  EX = CFG%CFG_%GET( KEY, VALUE )
!$omp end critical(FCKIT_YAMLCONFIGURATION)
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.EX, ERRFLAG_UNABLE_TO_READ_LOGICAL )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    CHARACTER(LEN=:), ALLOCATABLE :: STR

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_CFG_NOT_ALLOCATED)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Configuration not allocated' )
    CASE (ERRFLAG_UNABLE_TO_READ_LOGICAL)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Unable to read bool from configuration' )
    CASE DEFAULT
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT( STR )

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point on error
  RETURN

END FUNCTION YAML_READ_LOGICAL
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


!>
!> @brief Checks if a string contains an integer.
!>
!> @section interface
!> @param [in] STRING   Input string representing the range (e.g. "1:10").
!> @param [out] MATCH   True if the string has the format "LO:HI".
!> @param [inout] HOOKS Utilities to be used for logging, debugging, tracing and option handling
!>
!> @return Integer error code (`RET`) indicating success or failure:
!>         - `0`: Success
!>         - `1`: Failure
!>
!> @section Dependencies of this function:
!>
!> @subsection module dependencies
!>   - @dependency [PROCEDURE] READ_INTEGER_PATTERNS
!>
!> @subsection local dependencies
!>   - @dependency [PARAMETER] DATAKINDS_DEF_MOD::JPIB_K
!>
!> @subsection special dependencies
!>   - @dependency [*] PP_DEBUG_USE_VARS::*
!>   - @dependency [*] PP_LOG_USE_VARS::*
!>   - @dependency [*] PP_TRACE_USE_VARS::*
!>
!> @see STRING_IS_INTEGER_RANGE
!> @see STRING_IS_INTEGER
!>
#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'STRING_IS_INTEGER'
PP_THREAD_SAFE FUNCTION STRING_IS_INTEGER( STRING, MATCH, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  CHARACTER(LEN=*), INTENT(IN)    :: STRING
  LOGICAL,          INTENT(OUT)   :: MATCH
  TYPE(HOOKS_T),    INTENT(INOUT) :: HOOKS

  ! Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  INTEGER(KIND=JPIB_K) :: COUNT
  LOGICAL :: LTMP

  ! Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PARSE_ERROR=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Parse the string
  PP_TRYCALL(ERRFLAG_PARSE_ERROR) READ_INTEGER_PATTERNS( STRING, LTMP, COUNT, HOOKS )

  ! Generate the match flag
  IF ( LTMP .AND. COUNT .NE. 1 ) THEN
    MATCH = .FALSE.
  ELSE
    MATCH = LTMP
  ENDIF

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    CHARACTER(LEN=:), ALLOCATABLE :: STR

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_PARSE_ERROR)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Failed to parse string: '//TRIM(ADJUSTL(STRING)) )
    CASE DEFAULT
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT( STR )

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point on error
  RETURN

END FUNCTION STRING_IS_INTEGER
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


!>
!> @brief Check if a string contains a range of integers with a specified step.
!>
!> This function checks if a string represents a range in the form of "LO:HI"
!>
!> @section interface
!> @param [in] STRING   Input string representing the range (e.g. "1:10").
!> @param [out] MATCH   True if the string has the format "LO:HI".
!> @param [inout] HOOKS Utilities to be used for logging, debugging, tracing and option handling
!>
!> @return Integer error code (`RET`) indicating success or failure:
!>         - `0`: Success
!>         - `1`: Failure
!>
!> @section Dependencies of this function:
!>
!> @subsection module dependencies
!>   - @dependency [PROCEDURE] READ_INTEGER_PATTERNS
!>
!> @subsection local dependencies
!>   - @dependency [PARAMETER] DATAKINDS_DEF_MOD::JPIB_K
!>
!> @subsection special dependencies
!>   - @dependency [*] PP_DEBUG_USE_VARS::*
!>   - @dependency [*] PP_LOG_USE_VARS::*
!>   - @dependency [*] PP_TRACE_USE_VARS::*
!>
!> @see STRING_IS_INTEGER_RANGE
!> @see STRING_IS_INTEGER
!>
#define PP_PROCEDURE_TYPE 'SUBROUTINE'
#define PP_PROCEDURE_NAME 'STRING_IS_INTEGER_RANGE'
PP_THREAD_SAFE FUNCTION STRING_IS_INTEGER_RANGE( STRING, MATCH, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  CHARACTER(LEN=*), INTENT(IN)    :: STRING
  LOGICAL,          INTENT(OUT)   :: MATCH
  TYPE(HOOKS_T),    INTENT(INOUT) :: HOOKS

  ! Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  INTEGER(KIND=JPIB_K) :: COUNT
  INTEGER(KIND=JPIB_K), DIMENSION(2) :: TMP
  LOGICAL :: LTMP

  ! Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PARSE_ERROR=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Parse the string
  PP_TRYCALL(ERRFLAG_PARSE_ERROR) READ_INTEGER_PATTERNS( STRING, LTMP, COUNT, HOOKS, VALUES=TMP )

  ! Generate the match flag
  MATCH = LTMP

  IF ( MATCH .AND. COUNT .NE. 2 ) THEN
    MATCH = .FALSE.
  ENDIF

  IF ( MATCH .AND. TMP(1).GT.TMP(2) ) THEN
    MATCH = .FALSE.
  ENDIF

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    CHARACTER(LEN=:), ALLOCATABLE :: STR

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_PARSE_ERROR)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Failed to parse string: '//TRIM(ADJUSTL(STRING)) )
    CASE DEFAULT
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT( STR )

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point on error
  RETURN

END FUNCTION STRING_IS_INTEGER_RANGE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


!>
!> @brief Check if a string contains a range of integers with a specified step.
!>
!> This function checks if a string represents a range in the form of "LO:HI:BY"
!>
!> @section interface
!> @param [in] STRING   Input string representing the range (e.g. "1:10:2").
!> @param [out] MATCH   True if the string has the format "LO:HI:BY".
!> @param [inout] HOOKS Utilities to be used for logging, debugging, tracing and option handling
!>
!> @return Integer error code (`RET`) indicating success or failure:
!>         - `0`: Success
!>         - `1`: Failure
!>
!> @section Dependencies of this function:
!>
!> @subsection module dependencies
!>   - @dependency [PROCEDURE] READ_INTEGER_PATTERNS
!>
!> @subsection local dependencies
!>   - @dependency [PARAMETER] DATAKINDS_DEF_MOD::JPIB_K
!>
!> @subsection special dependencies
!>   - @dependency [*] PP_DEBUG_USE_VARS::*
!>   - @dependency [*] PP_LOG_USE_VARS::*
!>   - @dependency [*] PP_TRACE_USE_VARS::*
!>
!> @see STRING_IS_INTEGER_RANGE
!> @see STRING_IS_INTEGER
!>
#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'STRING_IS_INTEGER_RANGE_BY'
PP_THREAD_SAFE FUNCTION STRING_IS_INTEGER_RANGE_BY( STRING, MATCH, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  CHARACTER(LEN=*), INTENT(IN)    :: STRING
  LOGICAL,          INTENT(OUT)   :: MATCH
  TYPE(HOOKS_T),    INTENT(INOUT) :: HOOKS

  ! Function return value
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  INTEGER(KIND=JPIB_K) :: COUNT
  INTEGER(KIND=JPIB_K), DIMENSION(3) :: TMP
  LOGICAL :: LTMP

  ! Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PARSE_ERROR=1_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Parse the string
  PP_TRYCALL(ERRFLAG_PARSE_ERROR) READ_INTEGER_PATTERNS( STRING, LTMP, COUNT, HOOKS, VALUES=TMP )

  ! Generate the match flag
  MATCH = LTMP

  IF ( MATCH .AND. COUNT .NE. 3 ) THEN
    MATCH = .FALSE.
  ENDIF

  IF ( MATCH .AND. TMP(1).GT.TMP(2) ) THEN
    MATCH = .FALSE.
  ENDIF

  IF ( MATCH .AND. TMP(3).LT.0 ) THEN
    MATCH = .FALSE.
  ENDIF

  IF ( MATCH .AND.TMP(3).GT.(TMP(2)-TMP(1)) ) THEN
    MATCH = .FALSE.
  ENDIF

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    CHARACTER(LEN=:), ALLOCATABLE :: STR

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_PARSE_ERROR)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Failed to parse string: '//TRIM(ADJUSTL(STRING)) )
    CASE DEFAULT
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT( STR )

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point on error
  RETURN

END FUNCTION STRING_IS_INTEGER_RANGE_BY
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


!>
!> @brief Converts a string to an integer value.
!>
!> This function parses the input `STRING` and converts it to an integer value (`VALUE`).
!> If the conversion fails, the function returns an error code.
!>
!> @section interface
!> @param [in] STRING   Input string representing the integer value.
!> @param [out] VALUE   The resulting integer value.
!> @param [inout] HOOKS Utilities to be used for logging, debugging, tracing and option handling
!>
!> @return Integer error code (`RET`) indicating success or failure:
!>         - `0`: Success
!>         - `1`: Failure
!>
!> @section Dependencies of this function:
!>
!> @subsubsection module dependencies
!>   - @dependency [PROCEDURE] READ_INTEGER_PATTERNS
!>
!> @subsection local dependencies
!>   - @dependency [PARAMETER] DATAKINDS_DEF_MOD::JPIB_K
!>
!> @subsection special dependencies
!>   - @dependency [*] PP_DEBUG_USE_VARS::*
!>   - @dependency [*] PP_LOG_USE_VARS::*
!>   - @dependency [*] PP_TRACE_USE_VARS::*
!>
!> @see STRING_TO_INTEGER_RANGE
!> @see STRING_IS_INTEGER
!>
#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'STRING_TO_INTEGER'
PP_THREAD_SAFE FUNCTION STRING_TO_INTEGER( STRING, VALUE, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)    :: STRING
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: VALUE
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  ! Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  INTEGER(KIND=JPIB_K) :: COUNT
  INTEGER(KIND=JPIB_K), DIMENSION(1) :: TMP
  LOGICAL :: MATCH

  ! Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PARSE_ERROR=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_NO_MATCH=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_WRONG_COUNT=3_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Parse the string
  PP_TRYCALL(ERRFLAG_PARSE_ERROR) READ_INTEGER_PATTERNS( STRING, MATCH, COUNT, HOOKS, VALUES=TMP )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.MATCH, ERRFLAG_NO_MATCH )
  PP_DEBUG_CRITICAL_COND_THROW( COUNT.NE.1, ERRFLAG_WRONG_COUNT )

  ! Assign the values
  VALUE=TMP(1)

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    CHARACTER(LEN=:), ALLOCATABLE :: STR
    CHARACTER(LEN=32) :: TMPSTR1

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_PARSE_ERROR)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Failed to parse string: '//TRIM(ADJUSTL(STRING)) )
    CASE (ERRFLAG_NO_MATCH)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'No match between string and expected pattern: '//TRIM(ADJUSTL(STRING)) )
    CASE (ERRFLAG_WRONG_COUNT)
      TMPSTR1 = REPEAT(' ', 32)
      WRITE(TMPSTR1, '(I32)') COUNT
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Wrong count:  expected=1, got='//TRIM(ADJUST(TMPSTR1)) )
    CASE DEFAULT
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT( STR )

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point on error
  RETURN

END FUNCTION STRING_TO_INTEGER
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


!>
!> @brief Converts a string into a range of integers.
!>
!> This function parses a string representing a range in the form of "LO:HI" and
!> converts it into integers `LO` and `HI`.
!>
!> @section interface
!> @param [in] STRING   Input string representing the range (e.g., "1:10").
!> @param [out] LO      The lower bound of the range (integer).
!> @param [out] HI      The upper bound of the range (integer).
!> @param [inout] HOOKS Utilities to be used for logging, debugging, tracing and option handling
!>
!> @return Integer error code (`RET`) indicating success or failure:
!>         - `0`: Success
!>         - `1`: Failure
!>
!> @section Dependencies of this function:
!>
!> @subsubsection module dependencies
!>   - @dependency [PROCEDURE] READ_INTEGER_PATTERNS
!>
!> @subsection local dependencies
!>   - @dependency [PARAMETER] DATAKINDS_DEF_MOD::JPIB_K
!>
!> @subsection special dependencies
!>   - @dependency [*] PP_DEBUG_USE_VARS::*
!>   - @dependency [*] PP_LOG_USE_VARS::*
!>   - @dependency [*] PP_TRACE_USE_VARS::*
!>
!> @see STRING_TO_INTEGER_RANGE_BY
!> @see STRING_IS_INTEGER
!>
#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'STRING_TO_INTEGER_RANGE'
PP_THREAD_SAFE FUNCTION STRING_TO_INTEGER_RANGE( STRING, LO, HI, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)    :: STRING
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: LO
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: HI
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  ! Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  INTEGER(KIND=JPIB_K) :: COUNT
  INTEGER(KIND=JPIB_K), DIMENSION(2) :: TMP
  LOGICAL :: MATCH

  ! Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PARSE_ERROR=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_NO_MATCH=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_WRONG_COUNT=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_WRONG_RANGE=4_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Parse the string
  PP_TRYCALL(ERRFLAG_PARSE_ERROR) READ_INTEGER_PATTERNS( STRING, MATCH, COUNT, HOOKS, VALUES=TMP )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.MATCH, ERRFLAG_NO_MATCH )
  PP_DEBUG_CRITICAL_COND_THROW( COUNT.NE.2, ERRFLAG_WRONG_COUNT )
  PP_DEBUG_CRITICAL_COND_THROW( TMP(1).GT.TMP(2), ERRFLAG_WRONG_RANGE )

  ! Assign the values
  LO=TMP(1)
  HI=TMP(2)

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    CHARACTER(LEN=:), ALLOCATABLE :: STR
    CHARACTER(LEN=32) :: TMPSTR1
    CHARACTER(LEN=32) :: TMPSTR2

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_PARSE_ERROR)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Failed to parse string: '//TRIM(ADJUSTL(STRING)) )
    CASE (ERRFLAG_NO_MATCH)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'No match between string and expected pattern: '//TRIM(ADJUSTL(STRING)) )
    CASE (ERRFLAG_WRONG_COUNT)
      TMPSTR1 = REPEAT(' ', 32)
      WRITE(TMPSTR1, '(I32)') COUNT
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Wrong count:  expected=2, got='//TRIM(ADJUST(TMPSTR1)) )
    CASE (ERRFLAG_WRONG_RANGE)
      TMPSTR1 = REPEAT(' ', 32)
      WRITE(TMPSTR1, '(I32)') TMP(1)
      TMPSTR2 = REPEAT(' ', 32)
      WRITE(TMPSTR2, '(I32)') TMP(2)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Wrong range lower bound bigger than the upper bound: lb='//TRIM(ADJUSTL(TMPSTR1))//', ub='//TRIM(ADJUSTL(TMPSTR2)) )
    CASE DEFAULT
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT( STR )

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point on error
  RETURN

END FUNCTION STRING_TO_INTEGER_RANGE
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


!>
!> @brief Converts a string into a range of integers with a specified step.
!>
!> This function parses a string representing a range in the form of "LO:HI:BY" and
!> converts it into integers `LO`, `HI`, and `BY`.
!>
!> @section interface
!> @param [in] STRING   Input string representing the range (e.g. "1:10:2" ).
!> @param [out] LO      The lower bound of the range (integer).
!> @param [out] HI      The upper bound of the range (integer).
!> @param [out] BY      The step size between the lower and upper bounds (integer).
!> @param [inout] HOOKS Utilities to be used for logging, debugging, tracing and option handling
!>
!> @return Integer error code (`RET`) indicating success or failure:
!>         - `0`: Success
!>         - `1`: Failure
!>
!> @section Dependencies of this function:
!>
!> @subsection module dependencies
!>   - @dependency [PROCEDURE] READ_INTEGER_PATTERNS
!>
!> @subsection local dependencies
!>   - @dependency [PARAMETER] DATAKINDS_DEF_MOD::JPIB_K
!>
!> @subsection special dependencies
!>   - @dependency [*] PP_DEBUG_USE_VARS::*
!>   - @dependency [*] PP_LOG_USE_VARS::*
!>   - @dependency [*] PP_TRACE_USE_VARS::*
!>
!> @see STRING_TO_INTEGER_RANGE
!> @see STRING_TO_INTEGER
!>
#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'STRING_TO_INTEGER_RANGE_BY'
PP_THREAD_SAFE FUNCTION STRING_TO_INTEGER_RANGE_BY( STRING, LO, HI, BY, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)    :: STRING
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: LO
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: HI
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: BY
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  ! Function result
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  INTEGER(KIND=JPIB_K) :: COUNT
  INTEGER(KIND=JPIB_K), DIMENSION(3) :: TMP
  LOGICAL :: MATCH

  ! Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_PARSE_ERROR=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_NO_MATCH=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_WRONG_COUNT=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_WRONG_RANGE=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_STEP_SIGN=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_STEP_SIZE=6_JPIB_K

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for logging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Parse the string
  PP_TRYCALL(ERRFLAG_PARSE_ERROR) READ_INTEGER_PATTERNS( STRING, MATCH, COUNT, HOOKS, VALUES=TMP )
  PP_DEBUG_CRITICAL_COND_THROW( .NOT.MATCH, ERRFLAG_NO_MATCH )
  PP_DEBUG_CRITICAL_COND_THROW( COUNT.NE.3, ERRFLAG_WRONG_COUNT )
  PP_DEBUG_CRITICAL_COND_THROW( TMP(1).GT.TMP(2), ERRFLAG_WRONG_RANGE )
  PP_DEBUG_CRITICAL_COND_THROW( TMP(3).LT.0, ERRFLAG_STEP_SIGN )
  PP_DEBUG_CRITICAL_COND_THROW( TMP(3).GT.(TMP(2)-TMP(1)), ERRFLAG_STEP_SIZE )

  ! Assign the values
  LO=TMP(1)
  HI=TMP(2)
  BY=TMP(3)

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    CHARACTER(LEN=:), ALLOCATABLE :: STR
    CHARACTER(LEN=32) :: TMPSTR1
    CHARACTER(LEN=32) :: TMPSTR2
    CHARACTER(LEN=32) :: TMPSTR3

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_PARSE_ERROR)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Failed to parse string: '//TRIM(ADJUSTL(STRING)) )
    CASE (ERRFLAG_NO_MATCH)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'No match between string and expected pattern: '//TRIM(ADJUSTL(STRING)) )
    CASE (ERRFLAG_WRONG_COUNT)
      TMPSTR1 = REPEAT(' ', 32)
      WRITE(TMPSTR1, '(I32)') COUNT
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Wrong count:  expected=3, got='//TRIM(ADJUST(TMPSTR1)) )
    CASE (ERRFLAG_WRONG_RANGE)
      TMPSTR1 = REPEAT(' ', 32)
      WRITE(TMPSTR1, '(I32)') TMP(1)
      TMPSTR2 = REPEAT(' ', 32)
      WRITE(TMPSTR2, '(I32)') TMP(2)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Wrong range lower bound bigger than the upper bound: lb='//TRIM(ADJUSTL(TMPSTR1))//', ub='//TRIM(ADJUSTL(TMPSTR2)) )
    CASE (ERRFLAG_STEP_SIGN)
      TMPSTR1 = REPEAT(' ', 32)
      WRITE(TMPSTR1, '(I32)') TMP(3)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Step must be greater than 0: '//TRIM(ADJUSTL(TMPSTR1)) )
    CASE (ERRFLAG_STEP_SIZE)
      TMPSTR1 = REPEAT(' ', 32)
      WRITE(TMPSTR1, '(I32)') TMP(1)
      TMPSTR2 = REPEAT(' ', 32)
      WRITE(TMPSTR2, '(I32)') TMP(2)
      TMPSTR3 = REPEAT(' ', 32)
      WRITE(TMPSTR3, '(I32)') TMP(3)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Step size too big: lb='//TRIM(ADJUSTL(TMPSTR1))//', ub='//TRIM(ADJUSTL(TMPSTR2))//', step='//TRIM(ADJUSTL(TMPSTR3)) )
    CASE DEFAULT
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT( STR )

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point on error
  RETURN

END FUNCTION STRING_TO_INTEGER_RANGE_BY
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


!>
!> @brief Reads and validates integer patterns in a string.
!>
!> This function reads and validates integer patterns from the input `STRING`. It returns
!> the count of valid integers found and optionally populates the `VALUES` array. It uses
!> a state machine to process the string, checking for valid separators and number formats.
!>
!> @section interface
!> @param [in]  STRING  Input string containing integer patterns to be parsed.
!> @param [out] MATCH   Logical flag set to `.TRUE.` if valid patterns are found, `.FALSE.` otherwise.
!> @param [out] COUNT   Number of valid integer patterns found in the `STRING`.
!> @param [inout] HOOKS Utilities to be used for logging, debugging, tracing and option handling
!> @param [out] VALUES  Optional array that will be populated with the parsed integers.
!>
!> @return Integer error code (`RET`) indicating success or failure of the operation.
!>         Possible values:
!>           - `0`: Success
!>           - `1`: Failure
!>
!> @section Dependencies of this function:
!>
!> @subsection module dependencies
!>   - @dependency [PROCEDURE] READ_INTEGER
!>
!> @subsection local dependencies
!>   - @dependency [PARAMETER] "DATAKINDS_DEF_MOD::JPIB_K"
!>
!> @subsection special dependencies
!>   - @dependency [*] "OM_DEBUG_MOD::*"
!>   - @dependency [*] "OM_TRACE_MOD::*"
!>   - @dependency [*] "OM_LOG_MOD::*"
!>
!> @see READ_INTEGER
!>
#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'READ_INTEGER_PATTERNS'
PP_THREAD_SAFE FUNCTION  READ_INTEGER_PATTERNS( INP_STRING, MATCH, COUNT, HOOKS, VALUES ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  CHARACTER(LEN=*),                             INTENT(IN)    :: INP_STRING
  LOGICAL,                                      INTENT(OUT)   :: MATCH
  INTEGER(KIND=JPIB_K),                         INTENT(OUT)   :: COUNT
  TYPE(HOOKS_T),                                INTENT(INOUT) :: HOOKS
  INTEGER(KIND=JPIB_K), DIMENSION(:), OPTIONAL, INTENT(OUT)   :: VALUES

  ! Function return value
  INTEGER(KIND=JPIB_K) :: RET

  ! Local variables
  CHARACTER(LEN=LEN_TRIM(INP_STRING)) :: STRING
  INTEGER(KIND=JPIB_K) :: SZ
  INTEGER(KIND=JPIB_K) :: GLB_IDX
  INTEGER(KIND=JPIB_K) :: LO
  INTEGER(KIND=JPIB_K) :: HI
  INTEGER(KIND=JPIB_K) :: TMP
  INTEGER(KIND=JPIB_K) :: OLD_STATE
  INTEGER(KIND=JPIB_K) :: STATE
  INTEGER(KIND=JPIB_K) :: ERR_IDX
  CHARACTER(LEN=1) :: C
  LOGICAL :: LOOP
  LOGICAL :: THROW

  ! Error Codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_OK=0_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_CHAR_IN_CHECK_FIRST_NUM=1_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_CHAR_IN_SEARCH_SEPARATOR=2_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_CHAR_IN_SEPARATOR=3_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_OOB_IN_OUT_VALUES=4_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_UNEXPECTED=5_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_FAILED_READ_INTEGER=6_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_GLB_IDX_LOWER_THAN_1=7_JPIB_K
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_GLB_IDX_BIGGER_THAN_STRING=8_JPIB_K

  ! States
  INTEGER(KIND=JPIB_K), PARAMETER :: ENTER_STATE=1
  INTEGER(KIND=JPIB_K), PARAMETER :: CHECK_PREFIX_STATE=2
  INTEGER(KIND=JPIB_K), PARAMETER :: CHECK_FIRST_NUMBER_NO_PULL_STATE=3
  INTEGER(KIND=JPIB_K), PARAMETER :: CHECK_FIRST_NUMBER_STATE=4
  INTEGER(KIND=JPIB_K), PARAMETER :: SEARCH_SEPARATOR_STATE=5
  INTEGER(KIND=JPIB_K), PARAMETER :: VALID_VALUE_STATE=6
  INTEGER(KIND=JPIB_K), PARAMETER :: LAST_VALID_VALUE_STATE=7
  INTEGER(KIND=JPIB_K), PARAMETER :: EXIT_STATE=8
  INTEGER(KIND=JPIB_K), PARAMETER :: ERROR_STATE=9
  INTEGER(KIND=JPIB_K), PARAMETER :: INVALID_STATE=666

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for loging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Initialization
  STRING = REPEAT(' ', LEN_TRIM(INP_STRING))
  SZ = LEN_TRIM(ADJUSTL(INP_STRING))
  STRING(1:SZ) = TRIM(ADJUSTL(INP_STRING))
  MATCH = .FALSE.
  COUNT = 0
  GLB_IDX = 1
  ERR_IDX = 0
  LO = 0
  HI = 0
  LOOP = .TRUE.
  THROW=.FALSE.
  OLD_STATE = INVALID_STATE
  STATE = ENTER_STATE
  StatesLoop: DO WHILE (LOOP)

    ! Save the old state
    OLD_STATE = STATE

    ! Check for out of bounds
    IF ( GLB_IDX .GT. LEN_TRIM(STRING) ) THEN
      ERR_IDX = ERRFLAG_GLB_IDX_BIGGER_THAN_STRING
      STATE=ERROR_STATE
    ELSEIF ( GLB_IDX .LT. 1 ) THEN
      ERR_IDX = ERRFLAG_GLB_IDX_LOWER_THAN_1
      STATE=ERROR_STATE
    ENDIF


    !> State machine
    SELECT CASE (STATE)

    !> Enter in the state machine
    CASE (ENTER_STATE)

      COUNT = 0
      GLB_IDX = 1
      STATE = CHECK_PREFIX_STATE

    !> Check the prefix (it can be '+', '-' or nothing)
    CASE (CHECK_PREFIX_STATE)

      C = STRING(GLB_IDX:GLB_IDX)
      LO = GLB_IDX
      IF ( (C.NE.'+') .AND. (C.NE.'-') ) THEN
        STATE = CHECK_FIRST_NUMBER_NO_PULL_STATE
      ELSE
        STATE = CHECK_FIRST_NUMBER_STATE
      ENDIF

    !> Check the first digit of the integer (it can be 1..9)
    CASE (CHECK_FIRST_NUMBER_NO_PULL_STATE)

      C = STRING(GLB_IDX:GLB_IDX)
      IF ( GLB_IDX.EQ.LEN_TRIM(STRING) .AND. (C.GE.'0') .AND. (C.LE.'9') ) THEN
        STATE = LAST_VALID_VALUE_STATE
      ELSEIF ( GLB_IDX.LT.LEN_TRIM(STRING) .AND. (C.GE.'1') .AND. (C.LE.'9') ) THEN
        STATE = SEARCH_SEPARATOR_STATE
      ELSE
        ERR_IDX = ERRFLAG_INVALID_CHAR_IN_CHECK_FIRST_NUM
        STATE=ERROR_STATE
      ENDIF

    !> Check the first digit of the integer (it can be 1..9)
    CASE (CHECK_FIRST_NUMBER_STATE)

      GLB_IDX = GLB_IDX + 1
      C = STRING(GLB_IDX:GLB_IDX)
      IF ( GLB_IDX.EQ.LEN_TRIM(STRING) .AND. (C.GE.'0') .AND. (C.LE.'9') ) THEN
        STATE = LAST_VALID_VALUE_STATE
      ELSEIF ( GLB_IDX.LT.LEN_TRIM(STRING) .AND. (C.GE.'1') .AND. (C.LE.'9') ) THEN
        STATE = SEARCH_SEPARATOR_STATE
      ELSE
        ERR_IDX = ERRFLAG_INVALID_CHAR_IN_CHECK_FIRST_NUM
        STATE=ERROR_STATE
      ENDIF

    !> Search the separator (loop until a separator is found valid characters are 0..9)
    CASE (SEARCH_SEPARATOR_STATE)

      GLB_IDX = GLB_IDX + 1
      C = STRING(GLB_IDX:GLB_IDX)
      IF ( (C.GE.'0') .AND. (C.LE.'9') ) THEN
        IF (GLB_IDX.EQ.LEN_TRIM(STRING)) THEN
          STATE = LAST_VALID_VALUE_STATE
        ELSE
          STATE = SEARCH_SEPARATOR_STATE
        ENDIF
      ELSEIF ( C.EQ.':' ) THEN
        STATE = VALID_VALUE_STATE
      ELSE
        ERR_IDX = ERRFLAG_INVALID_CHAR_IN_SEARCH_SEPARATOR
        STATE = ERROR_STATE
      ENDIF

    !> Read the value, and search the next value or exit
    CASE (VALID_VALUE_STATE)

      HI = GLB_IDX - 1
      COUNT = COUNT + 1

      IF ( PRESENT(VALUES) ) THEN
        IF ( READ_INTEGER( STRING(LO:HI), TMP, HOOKS ) .NE. 0 ) THEN
          ERR_IDX = ERRFLAG_FAILED_READ_INTEGER
          STATE = ERROR_STATE
        ELSE
          IF ( COUNT .GT. SIZE(VALUES) ) THEN
            ERR_IDX = ERRFLAG_OOB_IN_OUT_VALUES
            STATE = ERROR_STATE
          ELSE
            VALUES(COUNT) = TMP
          ENDIF
        ENDIF
      ENDIF

      GLB_IDX = GLB_IDX + 1
      STATE = CHECK_PREFIX_STATE

    !> Read the value, and search the next value or exit
    CASE (LAST_VALID_VALUE_STATE)

      HI = GLB_IDX
      COUNT = COUNT + 1

      IF ( PRESENT(VALUES) ) THEN
        IF ( READ_INTEGER( STRING(LO:HI), TMP, HOOKS ) .NE. 0 ) THEN
          ERR_IDX = ERRFLAG_FAILED_READ_INTEGER
          STATE = ERROR_STATE
        ELSE
          IF ( COUNT .GT. SIZE(VALUES) ) THEN
            ERR_IDX = ERRFLAG_OOB_IN_OUT_VALUES
            STATE = ERROR_STATE
          ELSE
            VALUES(COUNT) = TMP
          ENDIF
        ENDIF
      ENDIF

      STATE = EXIT_STATE

    !> Exit on success from the state machine
    CASE (EXIT_STATE)

      MATCH = .TRUE.
      LOOP  = .FALSE.
      THROW = .FALSE.
      ERR_IDX = ERRFLAG_OK

    !> Exit on error from the state machine
    CASE (ERROR_STATE)

      COUNT = -ERR_IDX
      MATCH = .FALSE.
      LOOP  = .FALSE.
      IF ( PRESENT(VALUES) ) THEN
        THROW = .TRUE.
      ELSE
        THROW = .FALSE.
      ENDIF

    !> Unhandled case
    CASE DEFAULT

      ERR_IDX = ERRFLAG_UNEXPECTED
      STATE = ERROR_STATE

    END SELECT

  ENDDO StatesLoop

  ! Error handling
  IF ( THROW ) THEN
    PP_DEBUG_CRITICAL_COND_THROW( ERR_IDX.NE.ERRFLAG_OK, ERR_IDX )
  ENDIF

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    CHARACTER(LEN=:), ALLOCATABLE :: STR
    CHARACTER(LEN=32) :: CPOS
    CHARACTER(LEN=32) :: CSTATE
    CHARACTER(LEN=32) :: CSTATEID
    CHARACTER(LEN=4096) :: TMPSTR

    TMPSTR=REPEAT(' ',4096)
    CPOS=REPEAT(' ',32)
    CSTATE=REPEAT(' ',32)
    CSTATEID=REPEAT(' ',32)

    WRITE(CPOS,'(I16)') GBL_IDX

    ! Handle different states
    SELECT CASE(OLD_STATE)
    CASE (ENTER_STATE)
      CSTATE='ENTER_STATE'
      CSTATEID='1'
    CASE (CHECK_FIRST_NUMBER_NO_PULL_STATE)
      CSTATE='CHECK_FIRST_NUMBER_NO_PULL_STATE'
      CSTATEID='2'
    CASE (CHECK_PREFIX_STATE)
      CSTATE='CHECK_PREFIX_STATE'
      CSTATEID='3'
    CASE (CHECK_FIRST_NUMBER_STATE)
      CSTATE='CHECK_FIRST_NUMBER_STATE'
      CSTATEID='4'
    CASE (SEARCH_SEPARATOR_STATE)
      CSTATE='SEARCH_SEPARATOR_STATE'
      CSTATEID='5'
    CASE (VALID_VALUE_STATE)
      CSTATE='VALID_VALUE_STATE'
      CSTATEID='6'
    CASE (LAST_VALID_VALUE_STATE)
      CSTATE='LAST_VALID_VALUE_STATE'
      CSTATEID='7'
    CASE (EXIT_STATE)
      CSTATE='EXIT_STATE'
      CSTATEID='8'
    CASE (ERROR_STATE)
      CSTATE='ERROR_STATE'
      CSTATEID='9'
    CASE ( INVALID_STATE )
      CSTATE='INVALID_STATE'
      CSTATEID='666'
    CASE DEFAULT
      CSTATE='UNKNOWN_STATE'
      CSTATEID='0'
    END SELECT

    ! Create the descriptive part of the error message
    TMPSTR='('
    TMPSTR=TRIM(ADJUSTL(TMPSTR))//'state="'//TRIM(ADJUSTL(CSTATE))//'"'
    TMPSTR=TRIM(ADJUSTL(TMPSTR))//', state_id='//TRIM(ADJUSTL(CSTATEID))
    TMPSTR=TRIM(ADJUSTL(TMPSTR))//', position='//TRIM(ADJUSTL(CPOS))
    TMPSTR=TRIM(ADJUSTL(TMPSTR))//', string="'//TRIM(ADJUSTL(STRING))//'"'
    TMPSTR=')'

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_INVALID_CHAR_IN_CHECK_FIRST_NUM)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Invalid character in check first number: '//TRIM(ADJUSTL(TMPSTR)) )
    CASE (ERRFLAG_INVALID_CHAR_IN_SEARCH_SEPARATOR)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Invalid character in search separator: '//TRIM(ADJUSTL(TMPSTR)) )
    CASE (ERRFLAG_INVALID_CHAR_IN_SEPARATOR)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Invalid character in separator: '//TRIM(ADJUSTL(TMPSTR)) )
    CASE (ERRFLAG_OOB_IN_OUT_VALUES)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Out of bounds in out values: '//TRIM(ADJUSTL(TMPSTR)) )
    CASE (ERRFLAG_UNEXPECTED)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Unexpected error: '//TRIM(ADJUSTL(TMPSTR)) )
    CASE (ERRFLAG_FAILED_READ_INTEGER)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Failed to read an integer: '//TRIM(ADJUSTL(TMPSTR)) )
    CASE (ERRFLAG_GLB_IDX_LOWER_THAN_1)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Global index lower than 1: '//TRIM(ADJUSTL(TMPSTR)) )
    CASE (ERRFLAG_GLB_IDX_BIGGER_THAN_STRING)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Global index bigger than string: '//TRIM(ADJUSTL(TMPSTR)) )
    CASE DEFAULT
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT( STR )

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point on error
  RETURN

END FUNCTION READ_INTEGER_PATTERNS
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE


!>
!> @brief Converts a substring to an integer value.
!>
!> This function attempts to read an integer value from the provided substring and store
!> it in `NUM`. The function returns a status code indicating whether the conversion was successful.
!>
!> @section interface
!> @param [in]  SUBSTR   Input substring to be parsed.
!> @param [out] NUM      Parsed integer value.
!> @param [inout] HOOKS Utilities to be used for logging, debugging, tracing and option handling
!>
!> @return [Integer] Error code indicating success or failure of the operation.
!>         - `0`: Success
!>         - `1`: Failure to read an integer
!>
!> @section Dependencies of this function:
!>
!> @subsection local dependencies
!>   - @dependency [PARAMETER] "DATAKINDS_DEF_MOD::JPIB_K"
!>
!> @subsection special dependencies
!>   - @dependency [*] "OM_DEBUG_MOD::*"
!>   - @dependency [*] "OM_TRACE_MOD::*"
!>   - @dependency [*] "OM_LOG_MOD::*"
!>
!> @see READ_INTEGER_PATTERNS
!>
#define PP_PROCEDURE_TYPE 'FUNCTION'
#define PP_PROCEDURE_NAME 'READ_INTEGER'
PP_THREAD_SAFE FUNCTION  READ_INTEGER( S, NUM, HOOKS ) RESULT(RET)

  ! Symbols imported from other modules within the project.
  USE :: DATAKINDS_DEF_MOD, ONLY: JPIB_K
  USE :: HOOKS_MOD,         ONLY: HOOKS_T

  ! Symbols imported by the preprocessor for debugging purposes
  PP_DEBUG_USE_VARS

  ! Symbols imported by the preprocessor for logging purposes
  PP_LOG_USE_VARS

  ! Symbols imported by the preprocessor for tracing purposes
  PP_TRACE_USE_VARS

IMPLICIT NONE

  ! Dummy arguments
  CHARACTER(LEN=*),     INTENT(IN)    :: S
  INTEGER(KIND=JPIB_K), INTENT(OUT)   :: NUM
  TYPE(HOOKS_T),        INTENT(INOUT) :: HOOKS

  ! Function return value
  INTEGER(KIND=JPIB_K) :: RET

  ! Local error codes
  INTEGER(KIND=JPIB_K), PARAMETER :: ERRFLAG_INVALID_STRING=1_JPIB_K

  ! Local variables
  INTEGER :: IOS

  ! Local variables declared by the preprocessor for debugging purposes
  PP_DEBUG_DECL_VARS

  ! Local variables declared by the preprocessor for loging purposes
  PP_LOG_DECL_VARS

  ! Local variables declared by the preprocessor for tracing purposes
  PP_TRACE_DECL_VARS

  ! Trace begin of procedure
  PP_TRACE_ENTER_PROCEDURE()

  ! Initialization of good path return value
  PP_SET_ERR_SUCCESS( RET )

  ! Read the integer from the string
  READ(S, *, IOSTAT=IOS) NUM
  PP_DEBUG_CRITICAL_COND_THROW( IOS .NE. 0, ERRFLAG_INVALID_STRING )

  ! Trace end of procedure (on success)
  PP_TRACE_EXIT_PROCEDURE_ON_SUCCESS()

  ! Exit point
  RETURN

! Error handler
PP_ERROR_HANDLER

  ! Initialization of bad path return value
  PP_SET_ERR_FAILURE( RET )

#if defined( PP_DEBUG_ENABLE_ERROR_HANDLING )
!$omp critical(ERROR_HANDLER)

  BLOCK

    ! Error handling variables
    CHARACTER(LEN=:), ALLOCATABLE :: STR

    ! Handle different errors
    SELECT CASE(ERRIDX)
    CASE (ERRFLAG_INVALID_STRING)
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'Unable to read an integer from a string: '//TRIM(ADJUSTL(S)) )
    CASE DEFAULT
      PP_DEBUG_CREATE_ERROR_MSG( STR, 'unhandled error' )
    END SELECT

    ! Trace end of procedure (on error)
    PP_TRACE_EXIT_PROCEDURE_ON_ERROR()

    ! Write the error message and stop the program
    PP_DEBUG_ABORT( STR )

  END BLOCK

!$omp end critical(ERROR_HANDLER)
#endif

  ! Exit point on error
  RETURN

END FUNCTION READ_INTEGER
#undef PP_PROCEDURE_NAME
#undef PP_PROCEDURE_TYPE

END MODULE YAML_CORE_UTILS_MOD
#undef PP_SECTION_NAME
#undef PP_SECTION_TYPE
#undef PP_FILE_NAME