! Include preprocessor utils
#include "output_manager_preprocessor_utils.h"
#include "output_manager_preprocessor_trace_utils.h"
#include "output_manager_preprocessor_logging_utils.h"
#include "output_manager_preprocessor_errhdl_utils.h"


#define PP_FILE_NAME 'plans_mod.F90'
#define PP_SECTION_TYPE 'MODULE'
#define PP_SECTION_NAME 'PLANS_MOD'
MODULE PLANS_MOD

  !> Symbols imported from other modules within the project.
  USE :: PLAN_MOD, ONLY: PLAN_T
  USE :: PLAN_MOD, ONLY: SPECIALIZED_PLAN_T

IMPLICIT NONE

TYPE :: PLAN_NODE_T

  !> Set of plans readed from YAML files
  TYPE(SPECIALIZED_PLAN_CONTAINER_T), POINTER, DIMENSION(:) :: SPLAN_ => NULL()

  TYPE(PLAN_NODE_T), POINTER :: NEXT_ => NULL()

END TYPE


!> @class A class that contains a set of plans that can be used to encode a message
TYPE :: PLANS_T

  !> Default visibility of the class
  PRIVATE

  !> YAML file name
  CHARACTER(LEN=128)  :: YAML_FILE_NAME=REPEAT(' ', 128)

  !> Set of plans readed from YAML files

  !> Theses are the default plans that are used to encode the messages
  !> Default plans are the fallback solution when no specialized plan is found
  TYPE(PLAN_T), DIMENSION(:), POINTER :: DEFAULT_PLANS_ => NULL()

  !> Theses are the specialized plans that are used to encode the messages
  TYPE(PLAN_T), DIMENSION(:), POINTER :: SPECIAL_PLANS_ => NULL()

CONTAINS

  !> Initialize the plans from the YAML files
  PROCEDURE, PUBLIC, PASS :: INIT  => PLANS_INIT

  !> Build an array of specialized plans from the plans
  !> for all then plans that matches the message
  PROCEDURE, PUBLIC, PASS :: MATCH => PLANS_MATCH

  !> Free all the memory allocated by the plans
  PROCEDURE, PUBLIC, PASS :: FREE  => PLANS_FREE

END TYPE


!> Initialize the plans from the YAML files
PUBLIC :: PLANS_T

CONTAINS


SUBROUTINE PLANS_INIT( THIS, PARAMS, YAML_FILE_NAME )
IMPLICIT NONE

!> Dummy arguments
CLASS(PLANS_T),   INTENT(IN)  :: THIS
TYPE(PARAMS_T),   INTENT(IN)  :: PARAMS
CHARACTER(LEN=*), INTENT(IN)  :: YAML_FILE_NAME

!> Local variables
TYPE(YAML_CONFIGURATION_T)  :: CFG
TYPE(YAML_CONFIGURATION_T)  :: ENCODING_RULES
TYPE(YAML_CONFIGURATION_T)  :: SPECIAL_ENCODING_RULE
TYPE(YAML_CONFIGURATION_T)  :: DEFAULT_ENCODING_RULE
TYPE(YAML_CONFIGURATIONS_T) :: DEFAULT_ENCODING_RULES
TYPE(YAML_CONFIGURATIONS_T) :: SPECIAL_ENCODING_RULES
INTEGER(KIND=JPIB_K) :: I
LOGICAL :: VERBOSE


!> Initialize the plans filename
THIS%YAML_FILE_NAME = YAML_FILE_NAME

!> Read the configuration from the YAML file
RET = YAML_NEW_CONFIGURATION_FROM_FILE( YAML_FILE_NAME, CFG, VERBOSE )

RET = YAML_GET_SUBCONFIGURATION( CFG, "encoding-rules", ENCODING_RULES, VERBOSE )
RET = YAML_GET_SUBCONFIGURATIONS( ENCODING_RULES, "special-encoding-rules", SPECIAL_ENCODING_RULES, VERBOSE )
RET = YAML_GET_SUBCONFIGURATIONS( ENCODING_RULES, "default-encoding-rules", DEFAULT_ENCODING_RULES, VERBOSE )

RET = YAML_GET_CONFIGURATIONS_SIZE( SPECIAL_ENCODING_RULES, SPECIAL_SIZE, VERBOSE )
ALLOCATE(THIS%SPECIAL_PLANS_(SPECIAL_SIZE))
DO I = 1, SPECIAL_SIZE
  RET = YAML_GET_CONFIGURATION_BY_IDX( SPECIAL_ENCODING_RULES, I, SPECIAL_ENCODING_RULE, VERBOSE )
  RET = THIS%SPECIAL_PLANS_(I)%INIT( PARAMS, SPECIAL_ENCODING_RULE, VERBOSE )
  RET = YAML_DELETE_CONFIGURATION( SPECIAL_ENCODING_RULE, VERBOSE )
ENDDO


RET = YAML_GET_CONFIGURATIONS_SIZE( DEFAULT_ENCODING_RULES, DEFAULT_SIZE, VERBOSE )
ALLOCATE(THIS%DEFAULT_PLANS_(DEFAULT_SIZE))
DO I = 1, DEFAULT_SIZE
  RET = YAML_GET_CONFIGURATION_BY_IDX( DEFAULT_ENCODING_RULES, I, DEFAULT_ENCODING_RULE, VERBOSE )
  RET = THIS%SPECIAL_PLANS_(I)%INIT( PARAMS, DEFAULT_ENCODING_RULE, VERBOSE )
  RET = YAML_DELETE_CONFIGURATION( DEFAULT_ENCODING_RULE, VERBOSE )
ENDDO


RET = YAML_DELETE_CONFIGURATIONS( DEFAULT_ENCODING_RULES, VERBOSE )
RET = YAML_DELETE_CONFIGURATIONS( SPECIAL_ENCODING_RULES, VERBOSE )
RET = YAML_DELETE_CONFIGURATION( ENCODING_RULES, VERBOSE )

RETURN

END SUBROUTINE PLANS_INIT


SUBROUTINE PLANS_FREE( THIS )
IMPLICIT NONE

!> Dummy arguments
CLASS(PLANS_T), INTENT(INOUT) :: THIS

INTEGER(KIND=JPIB_K) :: I

THIS%YAML_FILE_NAME = REPEAT(' ', 128)

DO I = 1, SIZE(THIS%DEFAULT_PLANS_)
  CALL THIS%DEFAULT_PLANS_(I)%FREE()
ENDDO
DEALLOCATE(THIS%DEFAULT_PLANS_)

DO I = 1, SIZE(THIS%SPECIAL_PLANS_)
  CALL THIS%SPECIAL_PLANS_(I)%FREE()
ENDDO
DEALLOCATE(THIS%SPECIAL_PLANS_)

RETURN

END SUBROUTINE PLANS_FREE



SUBROUTINE PLANS_MATCH( THIS, PARAMS, MSG, MATCH, ENCODING_INFO )

  !>  Symbols imported from other modules within the project.
  USE :: MESSAGE_MOD, ONLY: MESSAGE_T

IMPLICIT NONE

!> Dummy arguments
CLASS(PLANS_T),        INTENT(IN)  :: THIS
TYPE(PARAMS_T),        INTENT(IN)  :: PARAMS
TYPE(MESSAGE_T),       INTENT(IN)  :: MSG
LOGICAL,               INTENT(OUT) :: MATCH
TYPE(ENCODING_INFO_T), INTENT(OUT) :: ENCODING_INFO

!> Local variables
TYPE(SPECIALIZED_PLAN_CONTAINER_T), POINTER, DIMENSION(:) :: CURR_PLAN
TYPE(PLAN_NODE_T), POINTER :: HEAD
TYPE(PLAN_NODE_T), POINTER :: CURR
INTEGER(KIND=JPIB_K) :: CNT
INTEGER(KIND=JPIB_K) :: I
LOGICAL :: MATCH

!> Match the palns
CURR_PLAN => NULL()
HEAD => NULL()
CURR => NULL()
CNT = 0
DO I = 1, SIZE(THIS%SPECIAL_PLANS_)
  CALL THIS%SPECIAL_PLANS_(I)%MATCH( PARAMS, MSG, MATCH, CURR_PLAN )
  IF ( MATCH ) THEN
    CNT = CNT + SIZE(CURR_PLAN)
    ALLOCATE(CURR)
    CURR%SPLAN_ => CURR_PLAN
    CURR_PLAN => NULL()
    IF ( .NOT. ASSOCIATED(HEAD) ) THEN
      HEAD => CURR
    ENDIF
    CURR => CURR%NEXT_
  ENDIF
ENDDO

IF ( CNT .EQ. 0 ) THEN

  DO I = 1, SIZE(THIS%DEFAULT_PLANS_)
    CALL THIS%DEFAULT_PLANS_(I)%MATCH( PARAMS, MSG, MATCH, CURR_PLAN )
    IF ( MATCH ) THEN
      CNT = CNT + SIZE(CURR_PLAN)
      ALLOCATE(CURR)
      CURR%SPLAN_ => CURR_PLAN
      CURR_PLAN => NULL()
      IF ( .NOT. ASSOCIATED(HEAD) ) THEN
        HEAD => CURR
      ENDIF
      CURR => CURR%NEXT_
    ENDIF
  ENDDO

  IF ( CNT .EQ. 0 ) THEN
    WRITE(*,*) 'ERROR: No plan matched the message'
  ELSEIF ( CNT .GT. 1 ) THEN
    WRITE(*,*) 'ERROR: Multiple default plans matched the message'
  ENDIF

ENDIF


IF ( CNT .GT. 0 ) THEN



  !> Allocate the array of specialized plans
  ALLOCATE(ENCODING_INFO%PLANS_(CNT))

  !> Build the array of specialized plans
  J = 0
  DO I = 1, CNT
    DO K = 1, SIZE(CURR%SPLAN_)
      J = J + 1
      ENCODING_INFO%PLANS_(K)%PLAN_ => CURR%SPLAN_(K)%SPLAN_
    ENDDO
    CURR => CURR%NEXT_
    DEALLOCATE(HEAD)
    HEAD => CURR
  ENDDO

ELSE

  WRITE(*,*) 'ERROR: No plan matched the message'

ENDIF

!> Exit point on success
RETURN

END SUBROUTINE PLANS_MATCH

END MODULE PLANS_MOD
#undef PP_SECTION_NAME
#undef PP_SECTION_TYPE
#undef PP_FILE_NAME